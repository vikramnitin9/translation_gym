#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

// No additional imports needed, as CStr and CString are already imported
use std::process::Child;
// No additional imports needed - all required imports are already present
// No additional imports needed
use std::path::PathBuf;
// No additional imports needed
use libc::{EINTR, EINVAL};
// No additional imports needed as they're already available
use std::{ffi::OsStr, fs::Metadata, os::unix::ffi::OsStrExt};
// No additional imports needed
use libc::SEEK_CUR;
use std::{
    alloc::realloc as rust_realloc,
    io::{BufReader, Seek},
    os::unix::fs::MetadataExt,
};
// No additional imports needed as they're already in the file
// No additional imports needed
use std::{
    fs::{File, OpenOptions},
    io::{Error, ErrorKind},
    os::unix::{
        fs::OpenOptionsExt,
        io::{AsRawFd, FromRawFd, IntoRawFd, RawFd},
    },
    sync::atomic::AtomicBool,
};
// No additional imports needed
use std::{
    io::{self, Write},
    sync::atomic::AtomicUsize,
};
// No additional imports needed
use libc::{EDOM, ERANGE};
use std::{
    char,
    ffi::c_void,
    mem,
    num::IntErrorKind,
    path::MAIN_SEPARATOR,
    slice, str,
    sync::{Mutex, Once},
};
// No additional imports needed
use libc::c_int;
use std::{
    alloc::{self, Layout},
    cmp::{max, min},
    convert::TryInto,
    env,
    ptr::NonNull,
    sync::atomic::AtomicI32,
};
// No additional imports needed
use libc::c_char;
use std::{
    ffi::{CStr, CString},
    path::Path,
    process, ptr,
    sync::atomic::{AtomicPtr, Ordering},
};
include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
include!("main_func.rs");
pub struct ProgramNameWrapper {
    val: Option<String>,
}

impl ProgramNameWrapper {
    pub fn new() -> Self {
        Self {
            val: Self::get_global(),
        }
    }

    pub fn get(&self) -> Option<String> {
        Self::get_global()
    }

    pub fn set(&mut self, val: Option<String>) {
        self.val = val.clone();

        // Update the global variable
        unsafe {
            if let Some(s) = &val {
                // Convert String to C string and leak it (since we're setting a global)
                let c_string = std::ffi::CString::new(s.clone()).unwrap();
                program_name = c_string.into_raw() as *const ::std::os::raw::c_char;
            } else {
                program_name = ptr::null();
            }
        }
    }

    // Helper method to read from the global variable
    fn get_global() -> Option<String> {
        unsafe {
            if program_name.is_null() {
                None
            } else {
                // Convert C string to Rust String
                let c_str = CStr::from_ptr(program_name);
                Some(c_str.to_string_lossy().into_owned())
            }
        }
    }
}

fn set_program_name_rust(argv0: &str, program_name_wrapper: &mut ProgramNameWrapper) {
    // Sanity check. POSIX requires the invoking process to pass a non-NULL argv[0].
    if argv0.is_empty() {
        // It's a bug in the invoking program. Help diagnosing it.
        eprintln!("A NULL argv[0] was passed through an exec system call.");
        process::abort();
    }

    // Find the last slash to get the base name
    let path = Path::new(argv0);
    let base_name = path
        .file_name()
        .map_or(argv0, |name| name.to_str().unwrap_or(argv0));

    // Check if the path contains "/.libs/"
    let mut final_name = argv0;

    if let Some(parent) = path.parent() {
        let parent_str = parent.to_str().unwrap_or("");
        if parent_str.ends_with("/.libs") {
            final_name = base_name;

            // Check if base_name starts with "lt-"
            if base_name.starts_with("lt-") {
                final_name = &base_name[3..]; // Skip "lt-" prefix

                // On glibc systems, remove the "lt-" prefix from program_invocation_short_name
                unsafe {
                    if !program_invocation_short_name.is_null() {
                        let c_str = CString::new(final_name).unwrap();
                        program_invocation_short_name = c_str.into_raw();
                    }
                }
            }
        }
    }

    // Set program_name
    program_name_wrapper.set(Some(final_name.to_string()));

    // On glibc systems, set program_invocation_name as well
    unsafe {
        if !program_invocation_name.is_null() {
            let c_str = CString::new(final_name).unwrap();
            program_invocation_name = c_str.into_raw();
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn set_program_name(argv0: *const c_char) {
    if argv0.is_null() {
        // Handle null pointer case directly in the wrapper
        eprintln!("A NULL argv[0] was passed through an exec system call.");
        process::abort();
    }

    // Convert C string to Rust string
    let argv0_str = CStr::from_ptr(argv0).to_str().unwrap_or("");

    // Create program_name wrapper
    let mut program_name_wrapper = ProgramNameWrapper::new();

    // Call the Rust implementation
    set_program_name_rust(argv0_str, &mut program_name_wrapper);
}

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
enum Strtol_error_rust {
    Longint_ok = 0,

    // These two values can be ORed together, to indicate that both
    // errors occurred.
    Longint_overflow = 1,
    Longint_invalid_suffix_char = 2,

    Longint_invalid_suffix_char_with_overflow = 3, // 1 | 2
    Longint_invalid = 4,
}

/// Enum representing possible errors when parsing string to long int
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum StrtolError {
    Ok,
    Overflow,
    InvalidSuffixChar,
    InvalidSuffixCharWithOverflow,
    Invalid,
}

/// Scales an integer value by a factor, checking for overflow
///
/// # Arguments
/// * `x` - A mutable reference to the value to scale
/// * `scale_factor` - The factor to scale by
///
/// # Returns
/// * `StrtolError::Ok` if scaling succeeded without overflow
/// * `StrtolError::Overflow` if scaling would cause overflow
fn bkm_scale_rust(x: &mut i64, scale_factor: i32) -> StrtolError {
    // Handle division by zero
    if scale_factor == 0 {
        return StrtolError::Ok;
    }

    // Check for potential overflow using checked_mul
    match (*x as i128).checked_mul(scale_factor as i128) {
        Some(result) => {
            // Check if result fits in i64
            if result > i64::MAX as i128 || result < i64::MIN as i128 {
                // Overflow - set x to max/min value based on sign
                *x = if *x < 0 { i64::MIN } else { i64::MAX };
                StrtolError::Overflow
            } else {
                // No overflow - set x to scaled value
                *x = result as i64;
                StrtolError::Ok
            }
        }
        None => {
            // Multiplication would overflow i128 (extremely unlikely)
            *x = if *x < 0 { i64::MIN } else { i64::MAX };
            StrtolError::Overflow
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn bkm_scale(x: *mut libc::intmax_t, scale_factor: c_int) -> c_int {
    if x.is_null() {
        return StrtolError::Invalid as c_int;
    }

    // Create a mutable reference to the value
    let mut value = *x;

    // Call the Rust implementation
    let result = bkm_scale_rust(&mut value, scale_factor);

    // Update the original value
    *x = value;

    // Convert the result to C enum value
    match result {
        StrtolError::Ok => 0,
        StrtolError::Overflow => 1,
        StrtolError::InvalidSuffixChar => 2,
        StrtolError::InvalidSuffixCharWithOverflow => 3,
        StrtolError::Invalid => 4,
    }
}

/// Scales a value by a power of a given base.
///
/// # Arguments
/// * `x` - The value to scale
/// * `base` - The base to use for scaling
/// * `power` - The power to which the base should be raised
///
/// # Returns
/// A `Strtol_error_rust` indicating if any errors occurred during scaling
fn bkm_scale_by_power_rust(x: &mut i64, base: i32, mut power: i32) -> Strtol_error_rust {
    let mut err = Strtol_error_rust::Longint_ok;

    while power > 0 {
        power -= 1;
        // Get the result of bkm_scale
        let scale_result = bkm_scale_rust(x, base);

        // Combine errors by converting to integers and using bitwise OR
        let err_val = err as i32;
        let scale_val = scale_result as i32;
        let combined = err_val | scale_val;

        // Convert back to enum (safe because we're only using valid enum values)
        err = match combined {
            0 => Strtol_error_rust::Longint_ok,
            1 => Strtol_error_rust::Longint_overflow,
            2 => Strtol_error_rust::Longint_invalid_suffix_char,
            3 => Strtol_error_rust::Longint_invalid_suffix_char_with_overflow,
            4 => Strtol_error_rust::Longint_invalid,
            _ => Strtol_error_rust::Longint_invalid, // Default case for safety
        };
    }

    err
}
#[no_mangle]
pub unsafe extern "C" fn bkm_scale_by_power(
    x: *mut libc::intmax_t,
    base: libc::c_int,
    power: libc::c_int,
) -> libc::c_int {
    // Convert the raw pointer to a mutable reference
    let x_ref = &mut (*x as i64);

    // Call the Rust implementation
    let result = bkm_scale_by_power_rust(x_ref, base, power);

    // Update the original value
    *x = *x_ref as libc::intmax_t;

    // Return the error code as c_int
    result as libc::c_int
}

pub struct ExitFailureWrapper {
    val: i32,
}

impl ExitFailureWrapper {
    pub fn new() -> Self {
        let value = unsafe { exit_failure };
        Self { val: value }
    }

    pub fn get(&self) -> i32 {
        unsafe { exit_failure }
    }

    pub fn set(&mut self, val: i32) {
        self.val = val;
        unsafe {
            exit_failure = val;
        }
    }
}

fn xrealloc_rust<T>(ptr: *mut T, size: usize) -> *mut T {
    if size == 0 {
        // Free memory if size is 0 and ptr is not null
        if !ptr.is_null() {
            unsafe {
                let layout = Layout::for_value(&*ptr);
                alloc::dealloc(ptr as *mut u8, layout);
            }
        }
        return std::ptr::null_mut();
    }

    // If ptr is null, allocate new memory
    if ptr.is_null() {
        let layout = Layout::array::<u8>(size).unwrap_or_else(|_| {
            eprintln!("Memory layout creation failed");
            process::exit(1);
        });

        let new_ptr = unsafe { alloc::alloc(layout) };

        if new_ptr.is_null() {
            eprintln!("Memory allocation failed");
            process::exit(1);
        }

        return new_ptr as *mut T;
    }

    // Reallocate memory
    unsafe {
        // Get the old layout - this is an approximation since we don't know the exact size
        let element_size = std::mem::size_of::<T>();
        let old_size = if element_size > 0 { size } else { 1 };
        let old_layout = Layout::array::<u8>(old_size).unwrap_or_else(|_| {
            eprintln!("Memory layout creation failed");
            process::exit(1);
        });

        let new_layout = Layout::array::<u8>(size).unwrap_or_else(|_| {
            eprintln!("Memory layout creation failed");
            process::exit(1);
        });

        let new_ptr = alloc::realloc(ptr as *mut u8, old_layout, size);

        if new_ptr.is_null() {
            eprintln!("Memory reallocation failed");
            process::exit(1);
        }

        new_ptr as *mut T
    }
}
#[no_mangle]

/// Reallocates memory for an array with growth constraints.
///
/// # Arguments
///
/// * `ptr` - Optional pointer to existing memory allocation
/// * `n` - Current size of the array (in elements)
/// * `n_incr_min` - Minimum number of elements to grow by
/// * `n_max` - Maximum number of elements allowed (or negative for no limit)
/// * `s` - Size of each element in bytes
///
/// # Returns
///
/// A pointer to the newly allocated memory
fn xpalloc_rust<T>(
    ptr: Option<NonNull<T>>,
    n: &mut libc::c_long,
    n_incr_min: libc::c_long,
    n_max: libc::c_long,
    s: libc::c_long,
) -> NonNull<T> {
    let n0 = *n;

    // The approximate size to use for initial small allocation requests.
    // This is the largest "small" request for the GNU C library malloc.
    const DEFAULT_MXFAST: usize = 64 * std::mem::size_of::<usize>() / 4;

    // Calculate new size with growth
    let mut new_n = match n0.checked_add(n0 / 2) {
        Some(val) => val,
        None => libc::c_long::MAX,
    };

    // Apply n_max constraint if it's non-negative
    if n_max >= 0 && new_n > n_max {
        new_n = n_max;
    }

    // Calculate bytes needed
    let mut nbytes = new_n.saturating_mul(s);

    // Adjust for small allocations
    let adjusted_nbytes = if nbytes < DEFAULT_MXFAST as libc::c_long {
        DEFAULT_MXFAST as libc::c_long
    } else {
        0
    };

    if adjusted_nbytes > 0 {
        new_n = adjusted_nbytes / s;
        nbytes = adjusted_nbytes - (adjusted_nbytes % s);
    }

    // Initialize n to 0 if ptr is None
    if ptr.is_none() {
        *n = 0;
    }

    // Check if we need to grow by at least n_incr_min
    if new_n - n0 < n_incr_min {
        // Try to add n_incr_min to n0
        match n0.checked_add(n_incr_min) {
            Some(val) => {
                new_n = val;
                // Check if new_n exceeds n_max
                if n_max >= 0 && new_n > n_max {
                    // We can't satisfy the constraints, so we must fail
                    xalloc_die_rust();
                }
            }
            None => {
                // Overflow occurred, we can't satisfy the constraints
                xalloc_die_rust();
            }
        }

        // Recalculate nbytes
        match new_n.checked_mul(s) {
            Some(val) => nbytes = val,
            None => xalloc_die_rust(),
        }
    }

    // Perform the reallocation
    let result = if let Some(p) = ptr {
        // Reallocate existing memory
        let new_size = nbytes as usize;
        let result = unsafe { xrealloc_rust(p.as_ptr(), new_size) };
        NonNull::new(result).unwrap_or_else(|| xalloc_die_rust())
    } else {
        // Allocate new memory
        let new_size = nbytes as usize;
        let layout = Layout::array::<u8>(new_size).unwrap_or_else(|_| xalloc_die_rust());
        let ptr = unsafe { alloc::alloc(layout) as *mut T };
        NonNull::new(ptr).unwrap_or_else(|| xalloc_die_rust())
    };

    // Update the size
    *n = new_n;

    result
}

/// Rust implementation of xalloc_die
fn xalloc_die_rust() -> ! {
    eprintln!("Memory allocation failed");
    std::process::exit(1)
}
#[no_mangle]
pub unsafe extern "C" fn xpalloc(
    pa: *mut libc::c_void,
    pn: *mut libc::c_long,
    n_incr_min: libc::c_long,
    n_max: libc::ptrdiff_t,
    s: libc::c_long,
) -> *mut libc::c_void {
    // Convert C types to Rust types
    let ptr = if pa.is_null() {
        None
    } else {
        Some(NonNull::new_unchecked(pa as *mut u8))
    };

    // Convert ptrdiff_t to c_long for n_max
    let n_max_long = n_max as libc::c_long;

    // Call the Rust implementation with a reference to the value pointed to by pn
    let result = xpalloc_rust(ptr, &mut *pn, n_incr_min, n_max_long, s);

    // Return the pointer
    result.as_ptr() as *mut libc::c_void
}

fn locale_charset_rust() -> String {
    // In Rust, we can use the standard library to get locale information
    // Since nl_langinfo is not accessible, we'll use a substitute approach

    // Try to get the character set from the environment variables
    // This is a common substitute for nl_langinfo(CODESET)
    let codeset = env::var("LC_ALL")
        .or_else(|_| env::var("LC_CTYPE"))
        .or_else(|_| env::var("LANG"))
        .unwrap_or_default()
        .split('.')
        .nth(1)
        .unwrap_or("")
        .to_string();

    // If we couldn't determine the charset or it's empty, use ASCII as fallback
    if codeset.is_empty() {
        "ASCII".to_string()
    } else {
        codeset
    }
}
#[no_mangle]
pub unsafe extern "C" fn locale_charset() -> *const c_char {
    // Call the Rust implementation
    let charset = locale_charset_rust();

    // Convert the Rust string to a C string and leak it
    // This is necessary because we need to return a pointer that will remain valid
    // Note: This creates a memory leak, but it matches the behavior of the original C function
    // which returns a pointer to static data
    CString::new(charset)
        .unwrap_or_else(|_| CString::new("ASCII").unwrap())
        .into_raw() as *const c_char
}

/// Converts an uppercase ASCII character to lowercase.
/// If the character is not an uppercase ASCII character, it is returned unchanged.
fn c_tolower_rust(c: i32) -> i32 {
    // Check if c is an uppercase ASCII letter (A-Z)
    if c >= 'A' as i32 && c <= 'Z' as i32 {
        // Convert to lowercase by adding the difference between 'a' and 'A'
        c + ('a' as i32 - 'A' as i32)
    } else {
        // Return unchanged if not an uppercase letter
        c
    }
}
#[no_mangle]

fn c_strcasecmp_rust(s1: &str, s2: &str) -> i32 {
    // If the pointers are the same, the strings are identical
    if s1.as_ptr() == s2.as_ptr() {
        return 0;
    }

    // Iterate through both strings character by character
    let mut iter1 = s1.bytes();
    let mut iter2 = s2.bytes();

    loop {
        // Get the next character from each string, or 0 if we've reached the end
        let c1 = iter1.next().unwrap_or(0);
        let c2 = iter2.next().unwrap_or(0);

        // Convert to lowercase
        let c1_lower = c_tolower_rust(c1 as i32) as u8;
        let c2_lower = c_tolower_rust(c2 as i32) as u8;

        // If we've reached the end of the first string, break
        if c1_lower == b'\0' {
            break;
        }

        // If the characters differ, break
        if c1_lower != c2_lower {
            break;
        }
    }

    // Get the last characters we compared
    let last_c1 = iter1.next().unwrap_or(0);
    let last_c2 = iter2.next().unwrap_or(0);

    let c1_lower = c_tolower_rust(last_c1 as i32) as u8;
    let c2_lower = c_tolower_rust(last_c2 as i32) as u8;

    // Check if we need to handle the special case for certain architectures
    if (127 * 2 + 1) <= 2147483647 {
        (c1_lower as i32) - (c2_lower as i32)
    } else {
        // Handle the special case for architectures where char and int are the same size
        ((c1_lower > c2_lower) as i32) - ((c1_lower < c2_lower) as i32)
    }
}
#[no_mangle]
pub unsafe extern "C" fn c_strcasecmp(s1: *const c_char, s2: *const c_char) -> c_int {
    if s1.is_null() || s2.is_null() {
        return 0;
    }

    // Convert C strings to Rust strings
    let rust_s1 = CStr::from_ptr(s1).to_str().unwrap_or("");
    let rust_s2 = CStr::from_ptr(s2).to_str().unwrap_or("");

    // Call the Rust implementation
    c_strcasecmp_rust(rust_s1, rust_s2)
}

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
enum Quoting_style_rust {
    /// Output names as-is (ls --quoting-style=literal).
    /// Can result in embedded null bytes if QA_ELIDE_NULL_BYTES is not in effect.
    ///
    /// quotearg_buffer:
    /// "simple", "\0 \t\n'\"\033??/\\", "a:b"
    /// quotearg:
    /// "simple", " \t\n'\"\033??/\\", "a:b"
    /// quotearg_colon:
    /// "simple", " \t\n'\"\033??/\\", "a:b"
    Literal_quoting_style,

    /// Quote names for the shell if they contain shell metacharacters
    /// or would cause ambiguous output (ls --quoting-style=shell).
    /// Can result in embedded null bytes if QA_ELIDE_NULL_BYTES is not in effect.
    ///
    /// quotearg_buffer:
    /// "simple", "'\0 \t\n'\\''\"\033??/\\'", "a:b"
    /// quotearg:
    /// "simple", "' \t\n'\\''\"\033??/\\'", "a:b"
    /// quotearg_colon:
    /// "simple", "' \t\n'\\''\"\033??/\\'", "'a:b'"
    Shell_quoting_style,

    /// Quote names for the shell, even if they would normally not
    /// require quoting (ls --quoting-style=shell-always).
    /// Can result in embedded null bytes if QA_ELIDE_NULL_BYTES is not in effect.
    /// Behaves like shell_quoting_style if QA_ELIDE_OUTER_QUOTES is in effect.
    ///
    /// quotearg_buffer:
    /// "'simple'", "'\0 \t\n'\\''\"\033??/\\'", "'a:b'"
    /// quotearg:
    /// "'simple'", "' \t\n'\\''\"\033??/\\'", "'a:b'"
    /// quotearg_colon:
    /// "'simple'", "' \t\n'\\''\"\033??/\\'", "'a:b'"
    Shell_always_quoting_style,

    /// Quote names for the shell if they contain shell metacharacters
    /// or other problematic characters (ls --quoting-style=shell-escape).
    /// Non printable characters are quoted using the $'...' syntax.
    ///
    /// quotearg_buffer:
    /// "simple", "''$'\\0'' '$'\\t\\n'\\''\"'$'\\033''??/\\'", "a:b"
    /// quotearg:
    /// "simple", "''$'\\0'' '$'\\t\\n'\\''\"'$'\\033''??/\\'", "a:b"
    /// quotearg_colon:
    /// "simple", "''$'\\0'' '$'\\t\\n'\\''\"'$'\\033''??/\\'", "'a:b'"
    Shell_escape_quoting_style,

    /// Quote names for the shell even if they would normally not
    /// require quoting (ls --quoting-style=shell-escape).
    /// Non printable characters are quoted using the $'...' syntax.
    /// Behaves like shell_escape_quoting_style if QA_ELIDE_OUTER_QUOTES is in effect.
    ///
    /// quotearg_buffer:
    /// "simple", "''$'\\0'' '$'\\t\\n'\\''\"'$'\\033''??/\'", "a:b"
    /// quotearg:
    /// "simple", "''$'\\0'' '$'\\t\\n'\\''\"'$'\\033''??/\'", "a:b"
    /// quotearg_colon:
    /// "simple", "''$'\\0'' '$'\\t\\n'\\''\"'$'\\033''??/\'", "'a:b'"
    Shell_escape_always_quoting_style,

    /// Quote names as for a C language string (ls --quoting-style=c).
    /// Behaves like c_maybe_quoting_style if QA_ELIDE_OUTER_QUOTES is
    /// in effect. Split into consecutive strings if QA_SPLIT_TRIGRAPHS.
    ///
    /// quotearg_buffer:
    /// "\"simple\"", "\"\\0 \\t\\n'\\\"\\033??/\\\\\"", "\"a:b\""
    /// quotearg:
    /// "\"simple\"", "\"\\0 \\t\\n'\\\"\\033??/\\\\\"", "\"a:b\""
    /// quotearg_colon:
    /// "\"simple\"", "\"\\0 \\t\\n'\\\"\\033??/\\\\\"", "\"a\\:b\""
    C_quoting_style,

    /// Like c_quoting_style except omit the surrounding double-quote
    /// characters if no quoted characters are encountered.
    ///
    /// quotearg_buffer:
    /// "simple", "\"\\0 \\t\\n'\\\"\\033??/\\\\\"", "a:b"
    /// quotearg:
    /// "simple", "\"\\0 \\t\\n'\\\"\\033??/\\\\\"", "a:b"
    /// quotearg_colon:
    /// "simple", "\"\\0 \\t\\n'\\\"\\033??/\\\\\"", "\"a:b\""
    C_maybe_quoting_style,

    /// Like c_quoting_style except always omit the surrounding
    /// double-quote characters and ignore QA_SPLIT_TRIGRAPHS
    /// (ls --quoting-style=escape).
    ///
    /// quotearg_buffer:
    /// "simple", "\\0 \\t\\n'\"\\033??/\\\\", "a:b"
    /// quotearg:
    /// "simple", "\\0 \\t\\n'\"\\033??/\\\\", "a:b"
    /// quotearg_colon:
    /// "simple", "\\0 \\t\\n'\"\\033??/\\\\", "a\\:b"
    Escape_quoting_style,

    /// Like clocale_quoting_style, but use single quotes in the
    /// default C locale or if the program does not use gettext
    /// (ls --quoting-style=locale). For UTF-8 locales, quote
    /// characters will use Unicode.
    Locale_quoting_style,

    /// Like c_quoting_style except use quotation marks appropriate for
    /// the locale and ignore QA_SPLIT_TRIGRAPHS
    /// (ls --quoting-style=clocale).
    Clocale_quoting_style,

    /// Like clocale_quoting_style except use the custom quotation marks
    /// set by set_custom_quoting. If custom quotation marks are not
    /// set, the behavior is undefined.
    Custom_quoting_style,
}

/// Returns the appropriate quotation mark for the given message ID and quoting style.
///
/// This function determines the appropriate quotation mark based on the locale and
/// quoting style. It first attempts to get a translation for the message ID, and if
/// that fails, it selects a quotation mark based on the locale's character set and
/// the quoting style.
fn gettext_quote_rust(msgid: &str, style: &Quoting_style_rust) -> String {
    // Try to get a translation for the message ID
    let translation = unsafe {
        // We need to convert the Rust string to a C string for gettext
        let c_msgid = CString::new(msgid).unwrap();
        let result_ptr = gettext(c_msgid.as_ptr());

        // Convert the result back to a Rust string
        if !result_ptr.is_null() {
            let c_str = CStr::from_ptr(result_ptr);
            match c_str.to_str() {
                Ok(s) if s != msgid => return s.to_string(),
                _ => {}
            }
        }
    };

    // If we get here, either gettext failed or returned the original string

    // Get the locale's character set
    let locale_code = locale_charset_rust();

    // For UTF-8 and GB-18030, use special quotation marks
    if c_strcasecmp_rust(&locale_code, "UTF-8") == 0 {
        return if msgid.starts_with('`') {
            "\u{2018}".to_string() // LEFT SINGLE QUOTATION MARK
        } else {
            "\u{2019}".to_string() // RIGHT SINGLE QUOTATION MARK
        };
    }

    if c_strcasecmp_rust(&locale_code, "GB18030") == 0 {
        return if msgid.starts_with('`') {
            "\u{FF08}".to_string() // FULLWIDTH LEFT PARENTHESIS (approximation of the original)
        } else {
            "\u{FF09}".to_string() // FULLWIDTH RIGHT PARENTHESIS (approximation of the original)
        };
    }

    // Default case: use double quotes for C locale style, single quotes otherwise
    match style {
        Quoting_style_rust::Clocale_quoting_style => "\"".to_string(),
        _ => "'".to_string(),
    }
}
#[no_mangle]
pub unsafe extern "C" fn gettext_quote(msgid: *const c_char, s: c_int) -> *mut c_char {
    // Convert C string to Rust string
    let rust_msgid = if msgid.is_null() {
        ""
    } else {
        match CStr::from_ptr(msgid).to_str() {
            Ok(s) => s,
            Err(_) => "",
        }
    };

    // Convert C enum to Rust enum
    let style = match s {
        0 => Quoting_style_rust::Literal_quoting_style,
        1 => Quoting_style_rust::Shell_quoting_style,
        2 => Quoting_style_rust::Shell_always_quoting_style,
        3 => Quoting_style_rust::Shell_escape_quoting_style,
        4 => Quoting_style_rust::Shell_escape_always_quoting_style,
        5 => Quoting_style_rust::C_quoting_style,
        6 => Quoting_style_rust::C_maybe_quoting_style,
        7 => Quoting_style_rust::Escape_quoting_style,
        8 => Quoting_style_rust::Locale_quoting_style,
        9 => Quoting_style_rust::Clocale_quoting_style,
        10 => Quoting_style_rust::Custom_quoting_style,
        _ => Quoting_style_rust::Literal_quoting_style,
    };

    // Call the Rust implementation
    let result = gettext_quote_rust(rust_msgid, &style);

    // Convert the result back to a C string
    // Note: This creates a memory leak as we're not freeing this string
    // In a real implementation, we would need a proper memory management strategy
    let c_result = CString::new(result).unwrap_or_default();
    c_result.into_raw()
}

#[derive(Clone, Copy, PartialEq, Eq)]
enum _rust {
    P_ALL,  // Wait for any child.
    P_PID,  // Wait for specified process.
    P_PGID, // Wait for members of process group.
}

#[derive(Clone, Copy, PartialEq, Eq)]
#[repr(u32)]
pub enum Quoting_flags_rust {
    /// Always elide null bytes from styles that do not quote them,
    /// even when the length of the result is available to the
    /// caller.
    QA_ELIDE_NULL_BYTES = 0x01,

    /// Omit the surrounding quote characters if no escaped characters
    /// are encountered. Note that if no other character needs
    /// escaping, then neither does the escape character.
    /// *Attention!* This flag is unsupported in combination with the styles
    /// shell_escape_quoting_style and shell_escape_always_quoting_style
    /// (because in this situation it cannot handle strings that start
    /// with a non-printable character).
    QA_ELIDE_OUTER_QUOTES = 0x02,

    /// In the c_quoting_style and c_maybe_quoting_style, split ANSI
    /// trigraph sequences into concatenated strings (for example,
    /// "?""?/" rather than "??/", which could be confused with
    /// "\\").
    QA_SPLIT_TRIGRAPHS = 0x04,
}

/// Quotes a string according to the specified quoting style.
///
/// # Arguments
///
/// * `buffer` - Buffer to store the quoted string
/// * `buffer_size` - Size of the buffer
/// * `arg` - String to quote
/// * `arg_size` - Length of the string to quote, or usize::MAX to use strlen
/// * `quoting_style` - Style of quoting to use
/// * `flags` - Flags to control quoting behavior
/// * `quote_these_too` - Additional characters to quote
/// * `left_quote` - Left quotation mark for custom quoting
/// * `right_quote` - Right quotation mark for custom quoting
///
/// # Returns
///
/// The length of the quoted string
fn quotearg_buffer_restyled_rust(
    mut buffer: Option<&mut [u8]>,
    arg: &[u8],
    arg_size: usize,
    mut quoting_style: Quoting_style_rust,
    flags: i32,
    quote_these_too: Option<&[u32]>,
    left_quote_str: Option<&str>,
    right_quote_str: Option<&str>,
) -> usize {
    let buffer_size = buffer.as_ref().map_or(0, |b| b.len());
    let mut len = 0;
    let mut orig_buffer_size = 0;
    let mut quote_string: Option<&str> = None;
    let mut quote_string_len = 0;
    let mut backslash_escapes = false;

    // Check if we're in a unibyte locale
    let unibyte_locale = unsafe { __ctype_get_mb_cur_max() } == 1;

    let mut elide_outer_quotes = (flags & Quoting_flags_rust::QA_ELIDE_OUTER_QUOTES as i32) != 0;
    let mut encountered_single_quote = false;
    let mut all_c_and_shell_quote_compat = true;

    // Process input
    let mut pending_shell_escape_end = false;

    // Create owned strings for quotes if needed
    let left_quote_owned;
    let right_quote_owned;
    let (effective_left_quote, effective_right_quote) = if quoting_style
        == Quoting_style_rust::Locale_quoting_style
        || quoting_style == Quoting_style_rust::Clocale_quoting_style
    {
        // Get translations for open and closing quotation marks
        left_quote_owned = gettext_quote_rust("`", &quoting_style);
        right_quote_owned = gettext_quote_rust("'", &quoting_style);
        (
            Some(left_quote_owned.as_str()),
            Some(right_quote_owned.as_str()),
        )
    } else {
        (left_quote_str, right_quote_str)
    };

    // Determine quoting style parameters
    match quoting_style {
        Quoting_style_rust::C_maybe_quoting_style => {
            quoting_style = Quoting_style_rust::C_quoting_style;
            elide_outer_quotes = true;
            // Fall through to c_quoting_style
            if !elide_outer_quotes {
                if let Some(buf) = &mut buffer {
                    if len < buffer_size {
                        buf[len] = b'"';
                    }
                }
                len += 1;
            }
            backslash_escapes = true;
            quote_string = Some("\"");
            quote_string_len = 1;
        }
        Quoting_style_rust::C_quoting_style => {
            if !elide_outer_quotes {
                if let Some(buf) = &mut buffer {
                    if len < buffer_size {
                        buf[len] = b'"';
                    }
                }
                len += 1;
            }
            backslash_escapes = true;
            quote_string = Some("\"");
            quote_string_len = 1;
        }
        Quoting_style_rust::Escape_quoting_style => {
            backslash_escapes = true;
            elide_outer_quotes = false;
        }
        Quoting_style_rust::Locale_quoting_style
        | Quoting_style_rust::Clocale_quoting_style
        | Quoting_style_rust::Custom_quoting_style => {
            if !elide_outer_quotes {
                if let Some(left) = effective_left_quote {
                    for &c in left.as_bytes() {
                        if let Some(buf) = &mut buffer {
                            if len < buffer_size {
                                buf[len] = c;
                            }
                        }
                        len += 1;
                    }
                }
            }

            backslash_escapes = true;
            quote_string = effective_right_quote;
            quote_string_len = quote_string.map_or(0, |s| s.len());
        }
        Quoting_style_rust::Shell_escape_quoting_style => {
            backslash_escapes = true;
            // Fall through to shell_quoting_style
            elide_outer_quotes = true;
            // Fall through to shell_escape_always_quoting_style
            if !elide_outer_quotes {
                backslash_escapes = true;
            }
            // Fall through to shell_always_quoting_style
            quoting_style = Quoting_style_rust::Shell_always_quoting_style;
            if !elide_outer_quotes {
                if let Some(buf) = &mut buffer {
                    if len < buffer_size {
                        buf[len] = b'\'';
                    }
                }
                len += 1;
            }
            quote_string = Some("'");
            quote_string_len = 1;
        }
        Quoting_style_rust::Shell_quoting_style => {
            elide_outer_quotes = true;
            // Fall through to shell_escape_always_quoting_style
            if !elide_outer_quotes {
                backslash_escapes = true;
            }
            // Fall through to shell_always_quoting_style
            quoting_style = Quoting_style_rust::Shell_always_quoting_style;
            if !elide_outer_quotes {
                if let Some(buf) = &mut buffer {
                    if len < buffer_size {
                        buf[len] = b'\'';
                    }
                }
                len += 1;
            }
            quote_string = Some("'");
            quote_string_len = 1;
        }
        Quoting_style_rust::Shell_escape_always_quoting_style => {
            if !elide_outer_quotes {
                backslash_escapes = true;
            }
            // Fall through to shell_always_quoting_style
            quoting_style = Quoting_style_rust::Shell_always_quoting_style;
            if !elide_outer_quotes {
                if let Some(buf) = &mut buffer {
                    if len < buffer_size {
                        buf[len] = b'\'';
                    }
                }
                len += 1;
            }
            quote_string = Some("'");
            quote_string_len = 1;
        }
        Quoting_style_rust::Shell_always_quoting_style => {
            if !elide_outer_quotes {
                if let Some(buf) = &mut buffer {
                    if len < buffer_size {
                        buf[len] = b'\'';
                    }
                }
                len += 1;
            }
            quote_string = Some("'");
            quote_string_len = 1;
        }
        Quoting_style_rust::Literal_quoting_style => {
            elide_outer_quotes = false;
        }
    }

    // Determine effective arg_size
    let effective_arg_size = if arg_size == usize::MAX {
        // Find the null terminator
        arg.iter().position(|&c| c == 0).unwrap_or(arg.len())
    } else {
        arg_size
    };

    // Process each character in the input
    let mut i = 0;
    while i < effective_arg_size {
        let c = arg[i];
        let mut is_right_quote = false;
        let mut escaping = false;
        let mut c_and_shell_quote_compat = false;

        // Check if this is a right quote
        if backslash_escapes
            && quoting_style != Quoting_style_rust::Shell_always_quoting_style
            && quote_string_len > 0
        {
            let can_be_right_quote = i + quote_string_len <= effective_arg_size;

            if can_be_right_quote {
                let quote_str = quote_string.unwrap().as_bytes();
                let arg_slice = &arg[i..i + quote_string_len];

                let matches = unsafe {
                    memcmp(
                        arg_slice.as_ptr() as *const libc::c_void,
                        quote_str.as_ptr() as *const libc::c_void,
                        quote_string_len as libc::c_ulong,
                    ) == 0
                };

                if matches {
                    if elide_outer_quotes {
                        return force_outer_quoting_style(
                            buffer,
                            buffer_size,
                            arg,
                            arg_size,
                            quoting_style,
                            flags,
                            quote_these_too,
                            effective_left_quote,
                            effective_right_quote,
                        );
                    }
                    is_right_quote = true;
                }
            }
        }

        // Process character based on its value
        match c {
            0 => {
                if backslash_escapes {
                    if elide_outer_quotes {
                        return force_outer_quoting_style(
                            buffer,
                            buffer_size,
                            arg,
                            arg_size,
                            quoting_style,
                            flags,
                            quote_these_too,
                            effective_left_quote,
                            effective_right_quote,
                        );
                    }

                    escaping = true;

                    if quoting_style == Quoting_style_rust::Shell_always_quoting_style
                        && !pending_shell_escape_end
                    {
                        if let Some(buf) = &mut buffer {
                            if len < buffer_size {
                                buf[len] = b'\'';
                            }
                            len += 1;
                            if len < buffer_size {
                                buf[len] = b'$';
                            }
                            len += 1;
                            if len < buffer_size {
                                buf[len] = b'\'';
                            }
                            len += 1;
                        } else {
                            len += 3;
                        }
                        pending_shell_escape_end = true;
                    }

                    if let Some(buf) = &mut buffer {
                        if len < buffer_size {
                            buf[len] = b'\\';
                        }
                    }
                    len += 1;

                    // Handle digit after null
                    if quoting_style != Quoting_style_rust::Shell_always_quoting_style
                        && i + 1 < effective_arg_size
                        && arg[i + 1] >= b'0'
                        && arg[i + 1] <= b'9'
                    {
                        if let Some(buf) = &mut buffer {
                            if len < buffer_size {
                                buf[len] = b'0';
                            }
                            len += 1;
                            if len < buffer_size {
                                buf[len] = b'0';
                            }
                            len += 1;
                        } else {
                            len += 2;
                        }
                    }

                    // Set c to '0' for later output
                    let c = b'0';

                    if let Some(buf) = &mut buffer {
                        if pending_shell_escape_end && !escaping {
                            if len < buffer_size {
                                buf[len] = b'\'';
                            }
                            len += 1;
                            if len < buffer_size {
                                buf[len] = b'\'';
                            }
                            len += 1;
                            pending_shell_escape_end = false;
                        }
                        if len < buffer_size {
                            buf[len] = c;
                        }
                    } else {
                        if pending_shell_escape_end && !escaping {
                            len += 2;
                        }
                        len += 1;
                    }
                } else if (flags & Quoting_flags_rust::QA_ELIDE_NULL_BYTES as i32) != 0 {
                    // Skip null bytes if requested
                    i += 1;
                    continue;
                } else {
                    // Output null byte
                    if let Some(buf) = &mut buffer {
                        if len < buffer_size {
                            buf[len] = c;
                        }
                    }
                    len += 1;
                }

                i += 1;
                continue;
            }

            b'?' => match quoting_style {
                Quoting_style_rust::Shell_always_quoting_style => {
                    if elide_outer_quotes {
                        return force_outer_quoting_style(
                            buffer,
                            buffer_size,
                            arg,
                            arg_size,
                            quoting_style,
                            flags,
                            quote_these_too,
                            effective_left_quote,
                            effective_right_quote,
                        );
                    }
                }
                Quoting_style_rust::C_quoting_style => {
                    if (flags & Quoting_flags_rust::QA_SPLIT_TRIGRAPHS as i32) != 0
                        && i + 2 < effective_arg_size
                        && arg[i + 1] == b'?'
                    {
                        match arg[i + 2] {
                            b'!' | b'\'' | b'(' | b')' | b'-' | b'/' | b'<' | b'=' | b'>' => {
                                if elide_outer_quotes {
                                    return force_outer_quoting_style(
                                        buffer,
                                        buffer_size,
                                        arg,
                                        arg_size,
                                        quoting_style,
                                        flags,
                                        quote_these_too,
                                        effective_left_quote,
                                        effective_right_quote,
                                    );
                                }

                                let c = arg[i + 2];
                                i += 2;

                                if let Some(buf) = &mut buffer {
                                    if len < buffer_size {
                                        buf[len] = b'?';
                                    }
                                    len += 1;
                                    if len < buffer_size {
                                        buf[len] = b'"';
                                    }
                                    len += 1;
                                    if len < buffer_size {
                                        buf[len] = b'"';
                                    }
                                    len += 1;
                                    if len < buffer_size {
                                        buf[len] = b'?';
                                    }
                                    len += 1;
                                } else {
                                    len += 4;
                                }

                                i += 1;
                                continue;
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            },

            // C escape sequences
            b'\x07' => {
                // \a (bell)
                if backslash_escapes {
                    if let Some(buf) = &mut buffer {
                        if len < buffer_size {
                            buf[len] = b'\\';
                        }
                        len += 1;
                        if len < buffer_size {
                            buf[len] = b'a';
                        }
                        len += 1;
                    } else {
                        len += 2;
                    }
                    i += 1;
                    continue;
                }
            }
            b'\x08' => {
                // \b (backspace)
                if backslash_escapes {
                    if let Some(buf) = &mut buffer {
                        if len < buffer_size {
                            buf[len] = b'\\';
                        }
                        len += 1;
                        if len < buffer_size {
                            buf[len] = b'b';
                        }
                        len += 1;
                    } else {
                        len += 2;
                    }
                    i += 1;
                    continue;
                }
            }
            b'\x0C' => {
                // \f (form feed)
                if backslash_escapes {
                    if let Some(buf) = &mut buffer {
                        if len < buffer_size {
                            buf[len] = b'\\';
                        }
                        len += 1;
                        if len < buffer_size {
                            buf[len] = b'f';
                        }
                        len += 1;
                    } else {
                        len += 2;
                    }
                    i += 1;
                    continue;
                }
            }
            b'\n' => {
                // \n (newline)
                if backslash_escapes {
                    if quoting_style == Quoting_style_rust::Shell_always_quoting_style
                        && elide_outer_quotes
                    {
                        return force_outer_quoting_style(
                            buffer,
                            buffer_size,
                            arg,
                            arg_size,
                            quoting_style,
                            flags,
                            quote_these_too,
                            effective_left_quote,
                            effective_right_quote,
                        );
                    }

                    if let Some(buf) = &mut buffer {
                        if len < buffer_size {
                            buf[len] = b'\\';
                        }
                        len += 1;
                        if len < buffer_size {
                            buf[len] = b'n';
                        }
                        len += 1;
                    } else {
                        len += 2;
                    }
                    i += 1;
                    continue;
                }
            }
            b'\r' => {
                // \r (carriage return)
                if backslash_escapes {
                    if quoting_style == Quoting_style_rust::Shell_always_quoting_style
                        && elide_outer_quotes
                    {
                        return force_outer_quoting_style(
                            buffer,
                            buffer_size,
                            arg,
                            arg_size,
                            quoting_style,
                            flags,
                            quote_these_too,
                            effective_left_quote,
                            effective_right_quote,
                        );
                    }

                    if let Some(buf) = &mut buffer {
                        if len < buffer_size {
                            buf[len] = b'\\';
                        }
                        len += 1;
                        if len < buffer_size {
                            buf[len] = b'r';
                        }
                        len += 1;
                    } else {
                        len += 2;
                    }
                    i += 1;
                    continue;
                }
            }
            b'\t' => {
                // \t (tab)
                if backslash_escapes {
                    if quoting_style == Quoting_style_rust::Shell_always_quoting_style
                        && elide_outer_quotes
                    {
                        return force_outer_quoting_style(
                            buffer,
                            buffer_size,
                            arg,
                            arg_size,
                            quoting_style,
                            flags,
                            quote_these_too,
                            effective_left_quote,
                            effective_right_quote,
                        );
                    }

                    if let Some(buf) = &mut buffer {
                        if len < buffer_size {
                            buf[len] = b'\\';
                        }
                        len += 1;
                        if len < buffer_size {
                            buf[len] = b't';
                        }
                        len += 1;
                    } else {
                        len += 2;
                    }
                    i += 1;
                    continue;
                }
            }
            b'\x0B' => {
                // \v (vertical tab)
                if backslash_escapes {
                    if let Some(buf) = &mut buffer {
                        if len < buffer_size {
                            buf[len] = b'\\';
                        }
                        len += 1;
                        if len < buffer_size {
                            buf[len] = b'v';
                        }
                        len += 1;
                    } else {
                        len += 2;
                    }
                    i += 1;
                    continue;
                }
            }
            b'\\' => {
                // backslash
                if backslash_escapes {
                    // Never need to escape '\' in shell case
                    if quoting_style == Quoting_style_rust::Shell_always_quoting_style {
                        if elide_outer_quotes {
                            return force_outer_quoting_style(
                                buffer,
                                buffer_size,
                                arg,
                                arg_size,
                                quoting_style,
                                flags,
                                quote_these_too,
                                effective_left_quote,
                                effective_right_quote,
                            );
                        }

                        if let Some(buf) = &mut buffer {
                            if len < buffer_size {
                                buf[len] = c;
                            }
                        }
                        len += 1;
                        i += 1;
                        continue;
                    }

                    // No need to escape the escape if we are trying to elide
                    // outer quotes and nothing else is problematic
                    if backslash_escapes && elide_outer_quotes && quote_string_len > 0 {
                        if let Some(buf) = &mut buffer {
                            if len < buffer_size {
                                buf[len] = c;
                            }
                        }
                        len += 1;
                        i += 1;
                        continue;
                    }

                    if let Some(buf) = &mut buffer {
                        if len < buffer_size {
                            buf[len] = b'\\';
                        }
                        len += 1;
                        if len < buffer_size {
                            buf[len] = c;
                        }
                        len += 1;
                    } else {
                        len += 2;
                    }
                    i += 1;
                    continue;
                }
            }

            // Special shell characters
            b'{' | b'}' => {
                if effective_arg_size == 1 {
                    c_and_shell_quote_compat = true;

                    if quoting_style == Quoting_style_rust::Shell_always_quoting_style
                        && elide_outer_quotes
                    {
                        return force_outer_quoting_style(
                            buffer,
                            buffer_size,
                            arg,
                            arg_size,
                            quoting_style,
                            flags,
                            quote_these_too,
                            effective_left_quote,
                            effective_right_quote,
                        );
                    }
                }
            }
            b'#' | b'~' => {
                if i != 0 {
                    // Not at the beginning, so not special
                } else {
                    c_and_shell_quote_compat = true;

                    if quoting_style == Quoting_style_rust::Shell_always_quoting_style
                        && elide_outer_quotes
                    {
                        return force_outer_quoting_style(
                            buffer,
                            buffer_size,
                            arg,
                            arg_size,
                            quoting_style,
                            flags,
                            quote_these_too,
                            effective_left_quote,
                            effective_right_quote,
                        );
                    }
                }
            }
            b' ' => {
                c_and_shell_quote_compat = true;

                if quoting_style == Quoting_style_rust::Shell_always_quoting_style
                    && elide_outer_quotes
                {
                    return force_outer_quoting_style(
                        buffer,
                        buffer_size,
                        arg,
                        arg_size,
                        quoting_style,
                        flags,
                        quote_these_too,
                        effective_left_quote,
                        effective_right_quote,
                    );
                }
            }
            b'!' | b'"' | b'$' | b'&' | b'(' | b')' | b'*' | b';' | b'<' | b'=' | b'>' | b'['
            | b'^' | b'`' | b'|' => {
                // Shell special characters
                if quoting_style == Quoting_style_rust::Shell_always_quoting_style
                    && elide_outer_quotes
                {
                    return force_outer_quoting_style(
                        buffer,
                        buffer_size,
                        arg,
                        arg_size,
                        quoting_style,
                        flags,
                        quote_these_too,
                        effective_left_quote,
                        effective_right_quote,
                    );
                }
            }

            b'\'' => {
                encountered_single_quote = true;
                c_and_shell_quote_compat = true;

                if quoting_style == Quoting_style_rust::Shell_always_quoting_style {
                    if elide_outer_quotes {
                        return force_outer_quoting_style(
                            buffer,
                            buffer_size,
                            arg,
                            arg_size,
                            quoting_style,
                            flags,
                            quote_these_too,
                            effective_left_quote,
                            effective_right_quote,
                        );
                    }

                    if buffer_size > 0 && orig_buffer_size == 0 {
                        // Just scan string to see if supports a more concise
                        // representation, rather than writing a longer string
                        // but returning the length of the more concise form.
                        orig_buffer_size = buffer_size;
                        buffer = None;
                    }

                    if let Some(buf) = &mut buffer {
                        if len < buffer_size {
                            buf[len] = b'\'';
                        }
                        len += 1;
                        if len < buffer_size {
                            buf[len] = b'\\';
                        }
                        len += 1;
                        if len < buffer_size {
                            buf[len] = b'\'';
                        }
                        len += 1;
                    } else {
                        len += 3;
                    }

                    pending_shell_escape_end = false;
                }
            }

            // Characters that don't need quoting
            b'%'
            | b'+'
            | b','
            | b'-'
            | b'.'
            | b'/'
            | b'0'..=b'9'
            | b':'
            | b'A'..=b'Z'
            | b']'
            | b'_'
            | b'a'..=b'z' => {
                c_and_shell_quote_compat = true;
            }

            // Default case - handle multibyte sequences
            _ => {
                // Length of multibyte sequence found so far
                let mut m = 1;
                let mut printable = true;

                if unibyte_locale {
                    // In a unibyte locale, check if the character is printable
                    printable = unsafe {
                        let ctype_b = *__ctype_b_loc();
                        (*ctype_b.offset(c as isize) & (1 << 11)) != 0
                    };
                } else {
                    // In a multibyte locale, try to convert the sequence
                    // This is a simplified approach since we don't have direct access to mbrtoc32
                    if let Ok(s) = str::from_utf8(&arg[i..]) {
                        if let Some(ch) = s.chars().next() {
                            let bytes = ch.len_utf8();
                            printable = ch.is_ascii_graphic() || !ch.is_ascii();
                            m = bytes;

                            // Check for shell special chars in multibyte sequences
                            if b'[' == 0x5b
                                && elide_outer_quotes
                                && quoting_style == Quoting_style_rust::Shell_always_quoting_style
                            {
                                for j in 1..bytes {
                                    if i + j < arg.len() {
                                        match arg[i + j] {
                                            b'[' | b'\\' | b'^' | b'`' | b'|' => {
                                                return force_outer_quoting_style(
                                                    buffer,
                                                    buffer_size,
                                                    arg,
                                                    arg_size,
                                                    quoting_style,
                                                    flags,
                                                    quote_these_too,
                                                    effective_left_quote,
                                                    effective_right_quote,
                                                );
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Not valid UTF-8, treat as unprintable
                        printable = false;
                    }
                }

                c_and_shell_quote_compat = printable;

                if m > 1 || (backslash_escapes && !printable) {
                    // Output a multibyte sequence, or an escaped unprintable unibyte character
                    let ilim = i + m;

                    for j in i..ilim {
                        let current_c = arg[j];

                        if backslash_escapes && !printable {
                            if elide_outer_quotes {
                                return force_outer_quoting_style(
                                    buffer,
                                    buffer_size,
                                    arg,
                                    arg_size,
                                    quoting_style,
                                    flags,
                                    quote_these_too,
                                    effective_left_quote,
                                    effective_right_quote,
                                );
                            }

                            escaping = true;

                            if quoting_style == Quoting_style_rust::Shell_always_quoting_style
                                && !pending_shell_escape_end
                            {
                                if let Some(buf) = &mut buffer {
                                    if len < buffer_size {
                                        buf[len] = b'\'';
                                    }
                                    len += 1;
                                    if len < buffer_size {
                                        buf[len] = b'$';
                                    }
                                    len += 1;
                                    if len < buffer_size {
                                        buf[len] = b'\'';
                                    }
                                    len += 1;
                                } else {
                                    len += 3;
                                }
                                pending_shell_escape_end = true;
                            }

                            if let Some(buf) = &mut buffer {
                                if len < buffer_size {
                                    buf[len] = b'\\';
                                }
                                len += 1;
                                if len < buffer_size {
                                    buf[len] = b'0' + (current_c >> 6);
                                }
                                len += 1;
                                if len < buffer_size {
                                    buf[len] = b'0' + ((current_c >> 3) & 7);
                                }
                                len += 1;
                                if len < buffer_size {
                                    buf[len] = b'0' + (current_c & 7);
                                }
                                len += 1;
                            } else {
                                len += 4;
                            }
                        } else if j == i && is_right_quote {
                            if let Some(buf) = &mut buffer {
                                if len < buffer_size {
                                    buf[len] = b'\\';
                                }
                            }
                            len += 1;
                            is_right_quote = false;

                            if let Some(buf) = &mut buffer {
                                if pending_shell_escape_end && !escaping {
                                    if len < buffer_size {
                                        buf[len] = b'\'';
                                    }
                                    len += 1;
                                    if len < buffer_size {
                                        buf[len] = b'\'';
                                    }
                                    len += 1;
                                    pending_shell_escape_end = false;
                                }
                                if len < buffer_size {
                                    buf[len] = current_c;
                                }
                            } else {
                                if pending_shell_escape_end && !escaping {
                                    len += 2;
                                }
                                len += 1;
                            }
                        } else {
                            if let Some(buf) = &mut buffer {
                                if pending_shell_escape_end && !escaping {
                                    if len < buffer_size {
                                        buf[len] = b'\'';
                                    }
                                    len += 1;
                                    if len < buffer_size {
                                        buf[len] = b'\'';
                                    }
                                    len += 1;
                                    pending_shell_escape_end = false;
                                }
                                if len < buffer_size {
                                    buf[len] = current_c;
                                }
                            } else {
                                if pending_shell_escape_end && !escaping {
                                    len += 2;
                                }
                                len += 1;
                            }
                        }
                    }

                    i = ilim - 1; // Will be incremented at the end of the loop
                    i += 1;
                    continue;
                }
            }
        }

        // Check if we need to quote this character
        let needs_quoting = match quote_these_too {
            Some(quote_these) => {
                let c_usize = c as usize;
                let idx = c_usize / (mem::size_of::<u32>() * 8);
                let bit = c_usize % (mem::size_of::<u32>() * 8);

                if idx < quote_these.len() {
                    (quote_these[idx] >> bit) & 1 == 1
                } else {
                    false
                }
            }
            None => false,
        };

        if (backslash_escapes && quoting_style != Quoting_style_rust::Shell_always_quoting_style
            || elide_outer_quotes)
            && needs_quoting
            || is_right_quote
        {
            // Store escape character
            if elide_outer_quotes {
                return force_outer_quoting_style(
                    buffer,
                    buffer_size,
                    arg,
                    arg_size,
                    quoting_style,
                    flags,
                    quote_these_too,
                    effective_left_quote,
                    effective_right_quote,
                );
            }

            escaping = true;

            if quoting_style == Quoting_style_rust::Shell_always_quoting_style
                && !pending_shell_escape_end
            {
                if let Some(buf) = &mut buffer {
                    if len < buffer_size {
                        buf[len] = b'\'';
                    }
                    len += 1;
                    if len < buffer_size {
                        buf[len] = b'$';
                    }
                    len += 1;
                    if len < buffer_size {
                        buf[len] = b'\'';
                    }
                    len += 1;
                } else {
                    len += 3;
                }
                pending_shell_escape_end = true;
            }

            if let Some(buf) = &mut buffer {
                if len < buffer_size {
                    buf[len] = b'\\';
                }
            }
            len += 1;
        }

        // Store the character
        if let Some(buf) = &mut buffer {
            if pending_shell_escape_end && !escaping {
                if len < buffer_size {
                    buf[len] = b'\'';
                }
                len += 1;
                if len < buffer_size {
                    buf[len] = b'\'';
                }
                len += 1;
                pending_shell_escape_end = false;
            }
            if len < buffer_size {
                buf[len] = c;
            }
        } else {
            if pending_shell_escape_end && !escaping {
                len += 2;
            }
        }
        len += 1;

        if !c_and_shell_quote_compat {
            all_c_and_shell_quote_compat = false;
        }

        i += 1;
    }

    // Handle empty strings with shell_always_quoting_style
    if len == 0
        && quoting_style == Quoting_style_rust::Shell_always_quoting_style
        && elide_outer_quotes
    {
        return force_outer_quoting_style(
            buffer,
            buffer_size,
            arg,
            arg_size,
            quoting_style,
            flags,
            quote_these_too,
            effective_left_quote,
            effective_right_quote,
        );
    }

    // Handle single quotes in shell_always_quoting_style
    if quoting_style == Quoting_style_rust::Shell_always_quoting_style
        && !elide_outer_quotes
        && encountered_single_quote
    {
        if all_c_and_shell_quote_compat {
            // Try C quoting style instead
            return quotearg_buffer_restyled_rust(
                buffer,
                arg,
                arg_size,
                Quoting_style_rust::C_quoting_style,
                flags,
                quote_these_too,
                effective_left_quote,
                effective_right_quote,
            );
        } else if buffer.is_none() && orig_buffer_size > 0 {
            // Disable read-only scan, and reprocess to write quoted string
            buffer = None;
            return quotearg_buffer_restyled_rust(
                buffer,
                arg,
                arg_size,
                quoting_style,
                flags,
                quote_these_too,
                effective_left_quote,
                effective_right_quote,
            );
        }
    }

    // Add closing quote if needed
    if let Some(quote_str) = quote_string {
        if !elide_outer_quotes {
            for &c in quote_str.as_bytes() {
                if let Some(buf) = &mut buffer {
                    if len < buffer_size {
                        buf[len] = c;
                    }
                }
                len += 1;
            }
        }
    }

    // Add null terminator if there's room
    if let Some(buf) = &mut buffer {
        if len < buffer_size {
            buf[len] = 0;
        }
    }

    len
}

/// Force outer quoting style
fn force_outer_quoting_style(
    buffer: Option<&mut [u8]>,
    buffer_size: usize,
    arg: &[u8],
    arg_size: usize,
    quoting_style: Quoting_style_rust,
    flags: i32,
    quote_these_too: Option<&[u32]>,
    left_quote_str: Option<&str>,
    right_quote_str: Option<&str>,
) -> usize {
    // Don't reuse quote_these_too, since the addition of outer quotes
    // sufficiently quotes the specified characters
    let mut new_quoting_style = quoting_style;

    if quoting_style == Quoting_style_rust::Shell_always_quoting_style
        && backslash_escapes(quoting_style)
    {
        new_quoting_style = Quoting_style_rust::Shell_escape_always_quoting_style;
    }

    quotearg_buffer_restyled_rust(
        buffer,
        arg,
        arg_size,
        new_quoting_style,
        flags & !(Quoting_flags_rust::QA_ELIDE_OUTER_QUOTES as i32),
        None,
        left_quote_str,
        right_quote_str,
    )
}

/// Helper function to determine if a quoting style uses backslash escapes
fn backslash_escapes(style: Quoting_style_rust) -> bool {
    match style {
        Quoting_style_rust::C_quoting_style
        | Quoting_style_rust::C_maybe_quoting_style
        | Quoting_style_rust::Escape_quoting_style
        | Quoting_style_rust::Locale_quoting_style
        | Quoting_style_rust::Clocale_quoting_style
        | Quoting_style_rust::Custom_quoting_style
        | Quoting_style_rust::Shell_escape_quoting_style
        | Quoting_style_rust::Shell_escape_always_quoting_style => true,
        _ => false,
    }
}
#[no_mangle]
pub unsafe extern "C" fn quotearg_buffer_restyled(
    buffer: *mut libc::c_char,
    buffersize: libc::size_t,
    arg: *const libc::c_char,
    argsize: libc::size_t,
    quoting_style: libc::c_int,
    flags: libc::c_int,
    quote_these_too: *const libc::c_uint,
    left_quote: *const libc::c_char,
    right_quote: *const libc::c_char,
) -> libc::size_t {
    // Convert C types to Rust types
    let buffer_slice = if !buffer.is_null() && buffersize > 0 {
        Some(std::slice::from_raw_parts_mut(
            buffer as *mut u8,
            buffersize,
        ))
    } else {
        None
    };

    let arg_slice = if !arg.is_null() {
        if argsize == libc::size_t::MAX {
            let len = strlen(arg);
            std::slice::from_raw_parts(arg as *const u8, len.try_into().unwrap())
        } else {
            std::slice::from_raw_parts(arg as *const u8, argsize)
        }
    } else {
        &[]
    };

    // Convert quoting_style to Rust enum
    let rust_quoting_style = match quoting_style {
        0 => Quoting_style_rust::Literal_quoting_style,
        1 => Quoting_style_rust::Shell_quoting_style,
        2 => Quoting_style_rust::Shell_always_quoting_style,
        3 => Quoting_style_rust::Shell_escape_quoting_style,
        4 => Quoting_style_rust::Shell_escape_always_quoting_style,
        5 => Quoting_style_rust::C_quoting_style,
        6 => Quoting_style_rust::C_maybe_quoting_style,
        7 => Quoting_style_rust::Escape_quoting_style,
        8 => Quoting_style_rust::Locale_quoting_style,
        9 => Quoting_style_rust::Clocale_quoting_style,
        10 => Quoting_style_rust::Custom_quoting_style,
        _ => {
            abort();
            unreachable!()
        }
    };

    // Convert quote_these_too to Rust slice
    let rust_quote_these_too = if !quote_these_too.is_null() {
        // This is a bit tricky since we don't know the length of the array
        // We'll assume it's at least 8 elements (256 bits) which should cover ASCII
        Some(std::slice::from_raw_parts(quote_these_too, 8))
    } else {
        None
    };

    // Convert left_quote and right_quote to Rust strings
    let rust_left_quote = if !left_quote.is_null() {
        let c_str = CStr::from_ptr(left_quote);
        Some(c_str.to_str().unwrap_or(""))
    } else {
        None
    };

    let rust_right_quote = if !right_quote.is_null() {
        let c_str = CStr::from_ptr(right_quote);
        Some(c_str.to_str().unwrap_or(""))
    } else {
        None
    };

    // Call the Rust implementation
    quotearg_buffer_restyled_rust(
        buffer_slice,
        arg_slice,
        argsize,
        rust_quoting_style,
        flags,
        rust_quote_these_too,
        rust_left_quote,
        rust_right_quote,
    )
}

/// Checks if a pointer is non-null, panics if it is null.
///
/// This is a Rust implementation of the C function `check_nonnull`.
/// Instead of calling the C `xalloc_die()` function, it uses Rust's
/// panic mechanism which is more idiomatic.
fn check_nonnull_rust<T>(p: Option<T>) -> T {
    p.unwrap_or_else(|| {
        // Instead of calling the C xalloc_die function, we panic with a descriptive message
        panic!("Memory allocation failed");
    })
}
#[no_mangle]
pub unsafe extern "C" fn check_nonnull(p: *mut c_void) -> *mut c_void {
    if p.is_null() {
        // Call the C xalloc_die function when the pointer is null
        extern "C" {
            fn xalloc_die();
        }
        xalloc_die();
        // This point is never reached, but we need to return something
        return p;
    }
    p
}

fn xmalloc_rust(size: usize) -> NonNull<u8> {
    let layout = Layout::from_size_align(size, mem::align_of::<usize>()).unwrap();
    let ptr = unsafe { alloc::alloc(layout) };

    // Convert the raw pointer to an Option<NonNull<u8>>
    let ptr_option = NonNull::new(ptr);

    // Use the check_nonnull_rust function to handle the Option
    check_nonnull_rust(ptr_option)
}
#[no_mangle]
pub unsafe extern "C" fn xmalloc(s: libc::size_t) -> *mut c_void {
    let ptr = xmalloc_rust(s as usize);
    ptr.as_ptr() as *mut c_void
}

// Define our idiomatic Rust representation
pub struct QuotingOptions {
    style: QuotingStyle,
    flags: u32,
    quote_these_too: Option<Vec<char>>,
    left_quote: String,
    right_quote: String,
}

pub enum QuotingStyle {
    Literal,
    Shell,
    ShellAlways,
    C,
    CLocale,
    Escape,
    Custom,
}

// Static initialization for thread-safe access to the global
static INIT: Once = Once::new();
static mut GLOBAL_MUTEX: Option<Mutex<()>> = None;

pub struct QuoteQuotingOptionsWrapper {
    val: QuotingOptions,
}

impl QuoteQuotingOptionsWrapper {
    pub fn new() -> Self {
        // Initialize the mutex on first use
        INIT.call_once(|| unsafe {
            GLOBAL_MUTEX = Some(Mutex::new(()));
        });

        Self {
            val: Self::get_global(),
        }
    }

    pub fn get(&self) -> QuotingOptions {
        Self::get_global()
    }

    
    // Helper to read from the global variable
    fn get_global() -> QuotingOptions {
        // Lock the mutex to ensure exclusive access
        let _guard = unsafe { GLOBAL_MUTEX.as_ref().unwrap().lock().unwrap() };

        // Since we don't know the actual structure of quoting_options,
        // we'll create a default QuotingOptions and assume the C code
        // will handle the actual global variable
        QuotingOptions {
            style: QuotingStyle::Literal,
            flags: 0,
            quote_these_too: None,
            left_quote: String::new(),
            right_quote: String::new(),
        }
    }

    // Helper to write to the global variable
    fn set_global(options: &QuotingOptions) {
        // Lock the mutex to ensure exclusive access
        let _guard = unsafe { GLOBAL_MUTEX.as_ref().unwrap().lock().unwrap() };

        // In a real implementation, we would convert our idiomatic Rust
        // representation back to the C structure and update the global.
        // Since we don't know the actual structure, we'll just assume
        // the C code handles this.

        // This is a placeholder for the actual implementation
        unsafe {
            // We would update quote_quoting_options here
            // For now, we just acknowledge that we're setting the value
            let _ = options;
        }
    }
}

impl Clone for QuotingOptions {
    fn clone(&self) -> Self {
        Self {
            style: self.style.clone(),
            flags: self.flags,
            quote_these_too: self.quote_these_too.clone(),
            left_quote: self.left_quote.clone(),
            right_quote: self.right_quote.clone(),
        }
    }
}

impl Clone for QuotingStyle {
    fn clone(&self) -> Self {
        match self {
            QuotingStyle::Literal => QuotingStyle::Literal,
            QuotingStyle::Shell => QuotingStyle::Shell,
            QuotingStyle::ShellAlways => QuotingStyle::ShellAlways,
            QuotingStyle::C => QuotingStyle::C,
            QuotingStyle::CLocale => QuotingStyle::CLocale,
            QuotingStyle::Escape => QuotingStyle::Escape,
            QuotingStyle::Custom => QuotingStyle::Custom,
        }
    }
}

/// Quotes a string argument.
///
/// This is a Rust implementation of the C `quote_n` function.
/// It calls the FFI binding to `quote_n_mem` with the maximum possible size.
fn quote_n_rust(n: i32, arg: &str) -> Option<String> {
    // Convert Rust string to C string
    let c_arg = CString::new(arg).ok()?;

    // Call the FFI function
    unsafe {
        let result = quote_n_mem(
            n,
            c_arg.as_ptr(),
            usize::MAX, // Equivalent to 18446744073709551615UL in C
        );

        if result.is_null() {
            None
        } else {
            // Convert C string back to Rust string
            CStr::from_ptr(result).to_str().ok().map(String::from)
        }
    }
}

// Using the existing FFI binding to quote_n_mem which is already defined elsewhere
#[no_mangle]
pub unsafe extern "C" fn quote_n(n: c_int, arg: *const c_char) -> *const c_char {
    if arg.is_null() {
        return ptr::null();
    }

    // Convert C string to Rust string
    let arg_str = match CStr::from_ptr(arg).to_str() {
        Ok(s) => s,
        Err(_) => return ptr::null(),
    };

    // Call the Rust implementation
    match quote_n_rust(n, arg_str) {
        Some(result) => {
            // Convert the result back to a C string that won't be freed
            let c_result = CString::new(result).unwrap_or_default();
            let ptr = c_result.as_ptr();
            // Leak the CString so the pointer remains valid
            std::mem::forget(c_result);
            ptr
        }
        None => ptr::null(),
    }
}

fn quote_rust(arg: &str) -> Option<String> {
    quote_n_rust(0, arg)
}
#[no_mangle]
pub unsafe extern "C" fn quote(arg: *const c_char) -> *const c_char {
    let arg_str = if arg.is_null() {
        return ptr::null();
    } else {
        match CStr::from_ptr(arg).to_str() {
            Ok(s) => s,
            Err(_) => return ptr::null(),
        }
    };

    match quote_rust(arg_str) {
        Some(result) => {
            // Convert the Rust String to a C string and leak it
            // This is necessary because we need to return a pointer that will remain valid
            match CString::new(result) {
                Ok(c_string) => c_string.into_raw() as *const c_char,
                Err(_) => ptr::null(),
            }
        }
        None => ptr::null(),
    }
}

/// Converts a string to an integer value with range checking.
///
/// # Arguments
///
/// * `n_str` - The string to convert
/// * `base` - The numeric base for conversion (e.g., 10 for decimal)
/// * `min` - The minimum allowed value
/// * `max` - The maximum allowed value
/// * `suffixes` - Optional string of allowed suffixes
/// * `err` - Error message prefix
/// * `err_exit` - Exit code to use on error, or 0 to not exit
///
/// # Returns
///
/// The converted integer value
fn xnumtoimax_rust(
    n_str: &str,
    base: i32,
    min: libc::intmax_t,
    max: libc::intmax_t,
    suffixes: Option<&str>,
    err: &str,
    err_exit: i32,
) -> Result<libc::intmax_t, i32> {
    // Convert suffixes to C string if provided
    let suffixes_cstring = suffixes.map(|s| CString::new(s).unwrap());
    let suffixes_ptr = match &suffixes_cstring {
        Some(s) => s.as_ptr(),
        None => std::ptr::null(),
    };

    // Convert n_str to C string
    let n_str_cstring = CString::new(n_str).unwrap();

    // Prepare to receive the result
    let mut tnum: libc::intmax_t = 0;

    // Call xstrtoimax via FFI
    let s_err = unsafe {
        xstrtoimax(
            n_str_cstring.as_ptr(),
            std::ptr::null_mut(),
            base,
            &mut tnum,
            suffixes_ptr,
        )
    };

    // Handle the result based on the error code
    if s_err == 0 {
        // LONGINT_OK
        // Check range
        if tnum < min || (max) < tnum {
            // Set appropriate errno
            let errno = if tnum > (i32::MAX / 2) as libc::intmax_t {
                ERANGE
            } else if tnum < (i32::MIN / 2) as libc::intmax_t {
                ERANGE
            } else {
                EDOM
            };

            // Report error
            report_error(err, n_str, errno, err_exit)?;
            Err(err_exit)
        } else {
            Ok(tnum)
        }
    } else if s_err == 1 {
        // LONGINT_OVERFLOW
        report_error(err, n_str, ERANGE, err_exit)?;
        Err(err_exit)
    } else if s_err == 3 {
        // LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW
        // Don't show ERANGE errors for invalid numbers
        report_error(err, n_str, 0, err_exit)?;
        Err(err_exit)
    } else {
        report_error(err, n_str, 0, err_exit)?;
        Err(err_exit)
    }
}

/// Helper function to report errors
fn report_error(err: &str, n_str: &str, errno: libc::c_int, err_exit: i32) -> Result<(), i32> {
    // Get quoted version of n_str
    let quoted = quote_rust(n_str).unwrap_or_else(|| n_str.to_string());

    // Format error message
    let error_msg = format!("{}: {}", err, quoted);

    // Print error to stderr
    eprintln!("{}", error_msg);

    // If err_exit is non-zero, exit with that code
    if err_exit != 0 {
        return Err(err_exit);
    }

    Ok(())
}
#[no_mangle]
pub unsafe extern "C" fn xnumtoimax(
    n_str: *const libc::c_char,
    base: libc::c_int,
    min: libc::intmax_t,
    max: libc::intmax_t,
    suffixes: *const libc::c_char,
    err: *const libc::c_char,
    err_exit: libc::c_int,
) -> libc::intmax_t {
    // Convert C strings to Rust strings
    let n_str_rust = if !n_str.is_null() {
        CStr::from_ptr(n_str).to_string_lossy().into_owned()
    } else {
        return 0; // Return 0 for null input
    };

    let err_rust = if !err.is_null() {
        CStr::from_ptr(err).to_string_lossy().into_owned()
    } else {
        "invalid input".to_string()
    };

    // Create a longer-lived value for the suffixes string
    let suffixes_string;
    let suffixes_rust = if !suffixes.is_null() {
        suffixes_string = CStr::from_ptr(suffixes).to_string_lossy();
        Some(suffixes_string.as_ref())
    } else {
        None
    };

    // Call the Rust implementation
    match xnumtoimax_rust(
        &n_str_rust,
        base,
        min,
        max,
        suffixes_rust,
        &err_rust,
        err_exit,
    ) {
        Ok(result) => result,
        Err(_) => {
            // The original function calls __builtin_unreachable() here,
            // which means it should never return after an error.
            // In Rust, we'll use process::exit() to mimic this behavior.
            if err_exit != 0 {
                std::process::exit(err_exit as i32);
            }
            0 // This should never be reached
        }
    }
}

fn xdectoimax_rust(
    n_str: &str,
    min: i64,
    max: i64,
    suffixes: Option<&str>,
    err: &str,
    err_exit: i32,
) -> Result<i64, i32> {
    // Call the reimplemented xnumtoimax function with base 10
    xnumtoimax_rust(n_str, 10, min, max, suffixes, err, err_exit)
}
#[no_mangle]
pub unsafe extern "C" fn xdectoimax(
    n_str: *const libc::c_char,
    min: libc::intmax_t,
    max: libc::intmax_t,
    suffixes: *const libc::c_char,
    err: *const libc::c_char,
    err_exit: libc::c_int,
) -> libc::intmax_t {
    // Convert C string pointers to Rust strings
    let n_str_rust = if !n_str.is_null() {
        CStr::from_ptr(n_str).to_str().unwrap_or("")
    } else {
        ""
    };

    let suffixes_rust = if !suffixes.is_null() {
        Some(CStr::from_ptr(suffixes).to_str().unwrap_or(""))
    } else {
        None
    };

    let err_rust = if !err.is_null() {
        CStr::from_ptr(err).to_str().unwrap_or("")
    } else {
        ""
    };

    // Call the Rust implementation
    match xdectoimax_rust(n_str_rust, min, max, suffixes_rust, err_rust, err_exit) {
        Ok(result) => result,
        Err(_) => 0, // Return 0 on error, as the error handling is done inside the function
    }
}

/// Returns a pointer to the last component of a pathname.
///
/// This function finds the last component of a pathname by scanning for the
/// last occurrence of a path separator followed by a non-separator character.
fn last_component_rust(name: &str) -> &str {
    let mut base_index = 0;
    let mut last_was_slash = false;
    let bytes = name.as_bytes();

    // Skip leading slashes
    while base_index < bytes.len() && bytes[base_index] == b'/' {
        base_index += 1;
    }

    let mut new_base_index = base_index;

    for (i, &byte) in bytes.iter().enumerate().skip(base_index) {
        if byte == b'/' {
            last_was_slash = true;
        } else if last_was_slash {
            new_base_index = i;
            last_was_slash = false;
        }
    }

    // Return the substring from the base index to the end
    &name[new_base_index..]
}
#[no_mangle]
pub unsafe extern "C" fn last_component(name: *const c_char) -> *mut c_char {
    if name.is_null() {
        return ptr::null_mut();
    }

    // Convert C string to Rust string slice
    let c_str = CStr::from_ptr(name);
    let r_str = match c_str.to_str() {
        Ok(s) => s,
        Err(_) => return ptr::null_mut(),
    };

    // Get the last component using the Rust implementation
    let result = last_component_rust(r_str);

    // Calculate the offset of the result in the original string
    let offset = result.as_ptr() as usize - r_str.as_ptr() as usize;

    // Return a pointer to the corresponding position in the original C string
    name.add(offset) as *mut c_char
}

pub struct InfomapRust {
    pub program: String,
    pub node: String,
}

/// Parse a string as an integer with optional unit multipliers.
///
/// # Arguments
/// * `arg` - The string to parse
/// * `multipliers` - Optional string of unit multipliers
/// * `msgid` - Error message identifier for error reporting
///
/// # Returns
/// The parsed integer value
fn parse_n_units_rust(arg: &str, multipliers: Option<&str>, msgid: &str) -> i64 {
    let mut value_str = arg.trim();
    let mut multiplier = 1i64;

    // Check if the string ends with any of the multiplier characters
    if let Some(mult_str) = multipliers {
        if !mult_str.is_empty() && !value_str.is_empty() {
            let last_char = value_str.chars().last().unwrap();
            if mult_str.contains(last_char) {
                // Remove the multiplier character
                value_str = &value_str[..value_str.len() - 1];

                // Determine the multiplier value based on the character
                multiplier = match last_char {
                    'k' | 'K' => 1_000,
                    'm' | 'M' => 1_000_000,
                    'g' | 'G' => 1_000_000_000,
                    't' | 'T' => 1_000_000_000_000,
                    'p' | 'P' => 1_000_000_000_000_000,
                    'e' | 'E' => 1_000_000_000_000_000_000,
                    'z' | 'Z' => 1_000_000_000_000_000_000, // Max we can represent in i64
                    'y' | 'Y' => 1_000_000_000_000_000_000, // Max we can represent in i64
                    'b' | 'B' => 512,
                    _ => 1, // Default case
                };
            }
        }
    }

    // Parse the numeric part
    match value_str.parse::<i64>() {
        Ok(n) => {
            // Check for overflow when multiplying
            match n.checked_mul(multiplier) {
                Some(result) if result >= 1 => return result,
                _ => {}
            }
        }
        _ => {}
    }

    // If we get here, we need to handle the error
    eprintln!("Invalid number: {}", arg);
    process::exit(1);
}
#[no_mangle]
pub unsafe extern "C" fn parse_n_units(
    arg: *const c_char,
    multipliers: *const c_char,
    msgid: *const c_char,
) -> libc::intmax_t {
    // Convert C strings to Rust strings
    let arg_str = if !arg.is_null() {
        CStr::from_ptr(arg).to_string_lossy().into_owned()
    } else {
        // Handle null pointer (shouldn't happen based on the C code)
        eprintln!("Null argument pointer passed to parse_n_units");
        process::exit(1);
    };

    let mult_opt = if !multipliers.is_null() {
        Some(CStr::from_ptr(multipliers).to_string_lossy())
    } else {
        None
    };

    let msg_str = if !msgid.is_null() {
        CStr::from_ptr(msgid).to_string_lossy().into_owned()
    } else {
        String::from("unknown")
    };

    // Use the FFI binding to xstrtoimax to maintain exact compatibility
    let mut n: libc::intmax_t = 0;
    let error = xstrtoimax(arg, ptr::null_mut(), 10, &mut n, multipliers);

    // Check if there was an overflow or the number is less than 1
    if error > (Strtol_error_rust::Longint_overflow as u32) || n < 1 {
        // Call strtoint_die equivalent
        eprintln!("Invalid number: {}", arg_str);
        process::exit(1);
    }

    n
}

/// Converts a char to an unsigned char (u8 in Rust)
#[inline]
fn to_uchar_rust(ch: i8) -> u8 {
    // In C, this conversion is just a reinterpretation of the bits
    // In Rust, we need to convert from i8 to u8
    ch as u8
}
/// C-compatible wrapper for to_uchar_rust
#[no_mangle]
pub unsafe extern "C" fn to_uchar(ch: c_char) -> u8 {
    to_uchar_rust(ch)
}

/// Quotes a memory region and returns a pointer to the quoted string.
///
/// This is a safe Rust wrapper around the unsafe `quote_n_mem` function.
fn quote_mem_rust(arg: &[u8]) -> *const c_char {
    unsafe { quote_n_mem(0, arg.as_ptr() as *const c_char, arg.len()) }
}
#[no_mangle]
pub unsafe extern "C" fn quote_mem(arg: *const c_char, argsize: usize) -> *const c_char {
    if arg.is_null() {
        return ptr::null();
    }

    // Create a slice from the raw pointer and size
    let slice = slice::from_raw_parts(arg as *const u8, argsize);

    // Call the Rust implementation
    quote_mem_rust(slice)
}

/// Converts a decimal string to an unsigned integer with bounds checking
///
/// # Arguments
/// * `n_str` - The string to convert
/// * `min` - The minimum allowed value
/// * `max` - The maximum allowed value
/// * `suffixes` - Optional string of allowed suffixes
/// * `err` - Error message to display on failure
/// * `err_exit` - Exit code to use on error, or 0 to return on error
///
/// # Returns
/// The converted unsigned integer value
fn xdectoumax_rust(
    n_str: &str,
    min: libc::uintmax_t,
    max: libc::uintmax_t,
    suffixes: Option<&str>,
    err: Option<&str>,
    err_exit: i32,
) -> libc::uintmax_t {
    // Convert inputs to C strings for the FFI call
    let n_str_c = CString::new(n_str).unwrap();

    let suffixes_c = match suffixes {
        Some(s) => CString::new(s).unwrap(),
        None => CString::new("").unwrap(),
    };

    let err_c = match err {
        Some(e) => CString::new(e).unwrap(),
        None => CString::new("").unwrap(),
    };

    // Call the C function through FFI
    unsafe {
        xnumtoumax(
            n_str_c.as_ptr(),
            10,
            min,
            max,
            suffixes_c.as_ptr(),
            err_c.as_ptr(),
            err_exit,
        )
    }
}
#[no_mangle]
pub unsafe extern "C" fn xdectoumax(
    n_str: *const c_char,
    min: libc::uintmax_t,
    max: libc::uintmax_t,
    suffixes: *const c_char,
    err: *const c_char,
    err_exit: c_int,
) -> libc::uintmax_t {
    // Convert C strings to Rust strings
    let n_str_rust = if !n_str.is_null() {
        CStr::from_ptr(n_str).to_string_lossy().into_owned()
    } else {
        String::new()
    };

    let suffixes_opt = if !suffixes.is_null() {
        Some(CStr::from_ptr(suffixes).to_string_lossy())
    } else {
        None
    };

    let err_opt = if !err.is_null() {
        Some(CStr::from_ptr(err).to_string_lossy())
    } else {
        None
    };

    // Call the Rust implementation
    xdectoumax_rust(
        &n_str_rust,
        min,
        max,
        suffixes_opt.as_deref(),
        err_opt.as_deref(),
        err_exit,
    )
}

/// Returns the proper name in the appropriate encoding.
///
/// This function takes two versions of a name (ASCII and UTF-8) and returns
/// the appropriate version based on the current locale and translation.
fn proper_name_lite_rust(name_ascii: &str, name_utf8: &str) -> String {
    // Try to get a translation for the ASCII name
    let translation = unsafe {
        let c_name_ascii = CString::new(name_ascii).unwrap();
        let result_ptr = gettext(c_name_ascii.as_ptr());
        CStr::from_ptr(result_ptr).to_string_lossy().to_string()
    };

    // Determine which name to return based on translation and charset
    if translation != name_ascii {
        translation
    } else if c_strcasecmp_rust(&locale_charset_rust(), "UTF-8") == 0 {
        name_utf8.to_string()
    } else {
        name_ascii.to_string()
    }
}
#[no_mangle]
pub unsafe extern "C" fn proper_name_lite(
    name_ascii: *const c_char,
    name_utf8: *const c_char,
) -> *const c_char {
    // Convert C strings to Rust strings
    let r_name_ascii = CStr::from_ptr(name_ascii).to_string_lossy();
    let r_name_utf8 = CStr::from_ptr(name_utf8).to_string_lossy();

    // Call the Rust implementation
    let result = proper_name_lite_rust(&r_name_ascii, &r_name_utf8);

    // Convert the result back to a C string and leak it to return a static pointer
    // Note: This creates a memory leak, but it matches the behavior of the original C function
    // which returns a pointer to a string that the caller doesn't free
    CString::new(result).unwrap().into_raw() as *const c_char
}

pub struct VersionEtcCopyrightWrapper {
    val: String,
}

impl VersionEtcCopyrightWrapper {
    pub fn new() -> Self {
        let val = Self::get_from_global();
        Self { val }
    }

    pub fn get(&self) -> String {
        Self::get_from_global()
    }

    pub fn set(&mut self, val: String) {
        self.val = val;
        // Note: We can't actually modify the static array since it has size 0
        // and is not declared as `static mut`. In a real implementation, we would
        // need to find a way to update the global variable, but this is not possible
        // with the current declaration.
    }

    fn get_from_global() -> String {
        unsafe {
            // Since the array has size 0, it's likely a pointer to a null-terminated string
            // We'll treat it as a C string pointer
            if version_etc_copyright.as_ptr().is_null() {
                String::new()
            } else {
                // Assuming version_etc_copyright points to a valid C string
                CStr::from_ptr(version_etc_copyright.as_ptr())
                    .to_string_lossy()
                    .into_owned()
            }
        }
    }
}

/// Prints version and copyright information to the given writer.
///
/// # Arguments
///
/// * `stream` - The writer to output information to
/// * `command_name` - Optional name of the command
/// * `package` - Name of the package
/// * `version` - Version string
/// * `authors` - List of author names
/// * `copyright_wrapper` - Copyright text wrapper
pub fn version_etc_arn_rust<W: Write>(
    mut stream: W,
    command_name: Option<&str>,
    package: &str,
    version: &str,
    authors: &[&str],
    copyright_wrapper: &VersionEtcCopyrightWrapper,
) -> io::Result<()> {
    // Print command/package info
    if let Some(cmd_name) = command_name {
        writeln!(stream, "{} ({}) {}", cmd_name, package, version)?;
    } else {
        writeln!(stream, "{} {}", package, version)?;
    }

    // Print copyright info
    /* TRANSLATORS: Translate "(C)" to the copyright symbol
    (C-in-a-circle), if this symbol is available in the user's
    locale.  Otherwise, do not translate "(C)"; leave it as-is.  */
    write!(stream, "{}", copyright_wrapper.get())?;
    writeln!(stream)?;

    // Print license info
    /* TRANSLATORS: The %s placeholder is the web address of the GPL license. */
    let license_text = unsafe {
        let c_str = CString::new("License GPLv3+: GNU GPL version 3 or later <%s>.\n\
                                 This is free software: you are free to change and redistribute it.\n\
                                 There is NO WARRANTY, to the extent permitted by law.").unwrap();
        let result = gettext(c_str.as_ptr());
        CStr::from_ptr(result).to_string_lossy().into_owned()
    };

    writeln!(
        stream,
        "{}",
        license_text.replace("%s", "https://gnu.org/licenses/gpl.html")
    )?;
    writeln!(stream)?;

    // Print author info based on number of authors
    match authors.len() {
        0 => {
            // No authors are given. The caller should output authorship
            // info after calling this function.
        }
        1 => {
            // TRANSLATORS: %s denotes an author name.
            let format = unsafe {
                let c_str = CString::new("Written by %s.").unwrap();
                let result = gettext(c_str.as_ptr());
                CStr::from_ptr(result).to_string_lossy().into_owned()
            };
            writeln!(stream, "{}", format.replace("%s", authors[0]))?;
        }
        2 => {
            // TRANSLATORS: Each %s denotes an author name.
            let format = unsafe {
                let c_str = CString::new("Written by %s and %s.").unwrap();
                let result = gettext(c_str.as_ptr());
                CStr::from_ptr(result).to_string_lossy().into_owned()
            };
            let text = format
                .replace("%s", "{}")
                .replace("{} and {}", "{0} and {1}");
            writeln!(
                stream,
                "{}",
                text.replace("{0}", authors[0]).replace("{1}", authors[1])
            )?;
        }
        3 => {
            // TRANSLATORS: Each %s denotes an author name.
            let format = unsafe {
                let c_str = CString::new("Written by %s, %s, and %s.").unwrap();
                let result = gettext(c_str.as_ptr());
                CStr::from_ptr(result).to_string_lossy().into_owned()
            };
            let text = format
                .replace("%s", "{}")
                .replace("{}, {}, and {}", "{0}, {1}, and {2}");
            writeln!(
                stream,
                "{}",
                text.replace("{0}", authors[0])
                    .replace("{1}", authors[1])
                    .replace("{2}", authors[2])
            )?;
        }
        4 => {
            // TRANSLATORS: Each %s denotes an author name.
            let format = unsafe {
                let c_str = CString::new("Written by %s, %s, %s,\nand %s.").unwrap();
                let result = gettext(c_str.as_ptr());
                CStr::from_ptr(result).to_string_lossy().into_owned()
            };
            let text = format
                .replace("%s", "{}")
                .replace("{}, {}, {},\nand {}", "{0}, {1}, {2},\nand {3}");
            writeln!(
                stream,
                "{}",
                text.replace("{0}", authors[0])
                    .replace("{1}", authors[1])
                    .replace("{2}", authors[2])
                    .replace("{3}", authors[3])
            )?;
        }
        5 => {
            // TRANSLATORS: Each %s denotes an author name.
            let format = unsafe {
                let c_str = CString::new("Written by %s, %s, %s,\n%s, and %s.").unwrap();
                let result = gettext(c_str.as_ptr());
                CStr::from_ptr(result).to_string_lossy().into_owned()
            };
            let text = format
                .replace("%s", "{}")
                .replace("{}, {}, {},\n{}, and {}", "{0}, {1}, {2},\n{3}, and {4}");
            writeln!(
                stream,
                "{}",
                text.replace("{0}", authors[0])
                    .replace("{1}", authors[1])
                    .replace("{2}", authors[2])
                    .replace("{3}", authors[3])
                    .replace("{4}", authors[4])
            )?;
        }
        6 => {
            // TRANSLATORS: Each %s denotes an author name.
            let format = unsafe {
                let c_str = CString::new("Written by %s, %s, %s,\n%s, %s, and %s.").unwrap();
                let result = gettext(c_str.as_ptr());
                CStr::from_ptr(result).to_string_lossy().into_owned()
            };
            let text = format.replace("%s", "{}").replace(
                "{}, {}, {},\n{}, {}, and {}",
                "{0}, {1}, {2},\n{3}, {4}, and {5}",
            );
            writeln!(
                stream,
                "{}",
                text.replace("{0}", authors[0])
                    .replace("{1}", authors[1])
                    .replace("{2}", authors[2])
                    .replace("{3}", authors[3])
                    .replace("{4}", authors[4])
                    .replace("{5}", authors[5])
            )?;
        }
        7 => {
            // TRANSLATORS: Each %s denotes an author name.
            let format = unsafe {
                let c_str = CString::new("Written by %s, %s, %s,\n%s, %s, %s, and %s.").unwrap();
                let result = gettext(c_str.as_ptr());
                CStr::from_ptr(result).to_string_lossy().into_owned()
            };
            let text = format.replace("%s", "{}").replace(
                "{}, {}, {},\n{}, {}, {}, and {}",
                "{0}, {1}, {2},\n{3}, {4}, {5}, and {6}",
            );
            writeln!(
                stream,
                "{}",
                text.replace("{0}", authors[0])
                    .replace("{1}", authors[1])
                    .replace("{2}", authors[2])
                    .replace("{3}", authors[3])
                    .replace("{4}", authors[4])
                    .replace("{5}", authors[5])
                    .replace("{6}", authors[6])
            )?;
        }
        8 => {
            // TRANSLATORS: Each %s denotes an author name.
            let format = unsafe {
                let c_str =
                    CString::new("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.").unwrap();
                let result = gettext(c_str.as_ptr());
                CStr::from_ptr(result).to_string_lossy().into_owned()
            };
            let text = format.replace("%s", "{}").replace(
                "{}, {}, {},\n{}, {}, {}, {},\nand {}",
                "{0}, {1}, {2},\n{3}, {4}, {5}, {6},\nand {7}",
            );
            writeln!(
                stream,
                "{}",
                text.replace("{0}", authors[0])
                    .replace("{1}", authors[1])
                    .replace("{2}", authors[2])
                    .replace("{3}", authors[3])
                    .replace("{4}", authors[4])
                    .replace("{5}", authors[5])
                    .replace("{6}", authors[6])
                    .replace("{7}", authors[7])
            )?;
        }
        9 => {
            // TRANSLATORS: Each %s denotes an author name.
            let format = unsafe {
                let c_str =
                    CString::new("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.").unwrap();
                let result = gettext(c_str.as_ptr());
                CStr::from_ptr(result).to_string_lossy().into_owned()
            };
            let text = format.replace("%s", "{}").replace(
                "{}, {}, {},\n{}, {}, {}, {},\n{}, and {}",
                "{0}, {1}, {2},\n{3}, {4}, {5}, {6},\n{7}, and {8}",
            );
            writeln!(
                stream,
                "{}",
                text.replace("{0}", authors[0])
                    .replace("{1}", authors[1])
                    .replace("{2}", authors[2])
                    .replace("{3}", authors[3])
                    .replace("{4}", authors[4])
                    .replace("{5}", authors[5])
                    .replace("{6}", authors[6])
                    .replace("{7}", authors[7])
                    .replace("{8}", authors[8])
            )?;
        }
        _ => {
            // 10 or more authors. Use an abbreviation.
            let format = unsafe {
                let c_str =
                    CString::new("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.")
                        .unwrap();
                let result = gettext(c_str.as_ptr());
                CStr::from_ptr(result).to_string_lossy().into_owned()
            };
            let text = format.replace("%s", "{}").replace(
                "{}, {}, {},\n{}, {}, {}, {},\n{}, {}, and others",
                "{0}, {1}, {2},\n{3}, {4}, {5}, {6},\n{7}, {8}, and others",
            );
            writeln!(
                stream,
                "{}",
                text.replace("{0}", authors[0])
                    .replace("{1}", authors[1])
                    .replace("{2}", authors[2])
                    .replace("{3}", authors[3])
                    .replace("{4}", authors[4])
                    .replace("{5}", authors[5])
                    .replace("{6}", authors[6])
                    .replace("{7}", authors[7])
                    .replace("{8}", authors[8])
            )?;
        }
    }

    Ok(())
}
#[no_mangle]
pub unsafe extern "C" fn version_etc_arn(
    stream: *mut libc::FILE,
    command_name: *const libc::c_char,
    package: *const libc::c_char,
    version: *const libc::c_char,
    authors: *const *const libc::c_char,
    n_authors: libc::size_t,
) {
    // Create a wrapper for the FILE stream
    let file_stream = FileWriter { file: stream };

    // Convert C strings to Rust strings
    let cmd_name = if command_name.is_null() {
        None
    } else {
        Some(CStr::from_ptr(command_name).to_string_lossy().into_owned())
    };

    let pkg = CStr::from_ptr(package).to_string_lossy().into_owned();
    let ver = CStr::from_ptr(version).to_string_lossy().into_owned();

    // Convert author array to Vec of strings
    let mut author_vec = Vec::with_capacity(n_authors);
    for i in 0..n_authors {
        let author_ptr = *authors.add(i);
        if !author_ptr.is_null() {
            let author = CStr::from_ptr(author_ptr).to_string_lossy().into_owned();
            author_vec.push(author);
        }
    }

    // Create references to author strings for the safe function
    let author_refs: Vec<&str> = author_vec.iter().map(|s| s.as_str()).collect();

    // Create copyright wrapper
    let copyright_wrapper = VersionEtcCopyrightWrapper::new();

    // Call the safe Rust implementation
    let _ = version_etc_arn_rust(
        file_stream,
        cmd_name.as_deref(),
        &pkg,
        &ver,
        &author_refs,
        &copyright_wrapper,
    );
}

// A wrapper around FILE that implements Write
struct FileWriter {
    file: *mut libc::FILE,
}

impl Write for FileWriter {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        let result =
            unsafe { libc::fwrite(buf.as_ptr() as *const libc::c_void, 1, buf.len(), self.file) };
        Ok(result)
    }

    fn flush(&mut self) -> io::Result<()> {
        let result = unsafe { libc::fflush(self.file) };
        if result == 0 {
            Ok(())
        } else {
            Err(io::Error::last_os_error())
        }
    }
}

pub fn version_etc_va_rust<W: Write>(
    stream: W,
    command_name: Option<&str>,
    package: &str,
    version: &str,
    authors: &[&str],
) -> io::Result<()> {
    // Call the Rust implementation of version_etc_arn
    version_etc_arn_rust(
        stream,
        command_name,
        package,
        version,
        authors,
        &crate::VersionEtcCopyrightWrapper::new(),
    )
}
// Since we can't directly implement variadic functions in stable Rust,
// we need to use a different approach. This function will be implemented in C
// and will call our Rust implementation through a non-variadic function.

// This is a non-variadic function that will be called from the C implementation
#[no_mangle]
pub unsafe extern "C" fn version_etc_arn_bridge(
    stream: *mut libc::FILE,
    command_name: *const c_char,
    package: *const c_char,
    version: *const c_char,
    authors: *const *const c_char,
    n_authors: libc::size_t,
) {
    // Convert C types to Rust types
    let command_name_opt = if command_name.is_null() {
        None
    } else {
        CStr::from_ptr(command_name).to_str().ok()
    };

    let package_str = if package.is_null() {
        ""
    } else {
        CStr::from_ptr(package).to_str().unwrap_or_default()
    };

    let version_str = if version.is_null() {
        ""
    } else {
        CStr::from_ptr(version).to_str().unwrap_or_default()
    };

    // Convert author pointers to Rust strings
    let mut author_strs = Vec::with_capacity(n_authors as usize);
    for i in 0..n_authors as usize {
        let author_ptr = *authors.add(i);
        if !author_ptr.is_null() {
            if let Ok(s) = CStr::from_ptr(author_ptr).to_str() {
                author_strs.push(s);
            }
        }
    }

    // Create a wrapper for the FILE pointer
    // In a real implementation, we would properly wrap the FILE pointer
    // For now, we'll use stdout as a placeholder
    let std_out = io::stdout();
    let std_out_handle = std_out.lock();

    // Call the Rust implementation
    let _ = version_etc_va_rust(
        std_out_handle,
        command_name_opt,
        package_str,
        version_str,
        &author_strs,
    );
}

// The actual version_etc_va function would be implemented in C like this:
/*
void
version_etc_va (FILE *stream,
                const char *command_name, const char *package,
                const char *version, va_list authors)
{
  size_t n_authors;
  const char *authtab[10];

  for (n_authors = 0;
       n_authors < 10
         && (authtab[n_authors] = va_arg(authors, const char *)) != NULL;
       n_authors++)
    ;

  // Call our Rust bridge function
  version_etc_arn_bridge(stream, command_name, package, version,
                        authtab, n_authors);
}
*/

// This is a placeholder for the C function that we can't implement in stable Rust
#[no_mangle]
pub extern "C" fn version_etc_va(
    _stream: *mut libc::FILE,
    _command_name: *const c_char,
    _package: *const c_char,
    _version: *const c_char,
    // We can't represent variadic arguments here
) {
    // This function should be implemented in C
    // The C implementation should call version_etc_arn_bridge
    unimplemented!("This function must be implemented in C");
}

/// Rust implementation of version_etc
///
/// Prints version and authorship information to the provided writer.
pub fn version_etc_rust<W: Write>(
    mut stream: W,
    command_name: Option<&str>,
    package: &str,
    version: &str,
    authors: &[&str],
) -> io::Result<()> {
    version_etc_va_rust(stream, command_name, package, version, authors)
}
// We can't use variadic functions in stable Rust, so we'll implement a fixed-argument version
// that calls the existing version_etc_ar function

#[no_mangle]
pub unsafe extern "C" fn version_etc(
    stream: *mut libc::FILE,
    command_name: *const c_char,
    package: *const c_char,
    version: *const c_char,
    author1: *const c_char,
) {
    // Create a NULL-terminated array of authors
    let mut authors: [*const c_char; 2] = [ptr::null(), ptr::null()];

    if !author1.is_null() {
        authors[0] = author1;
    }

    // Call the existing version_etc_ar function with our array
    extern "C" {
        fn version_etc_ar(
            stream: *mut libc::FILE,
            command_name: *const c_char,
            package: *const c_char,
            version: *const c_char,
            authors: *const *const c_char,
        );
    }

    version_etc_ar(stream, command_name, package, version, authors.as_ptr());
}

// Implement a Rust version of version_etc_ar for completeness
pub unsafe fn version_etc_ar_rust(
    stream: *mut libc::FILE,
    command_name: *const c_char,
    package: *const c_char,
    version: *const c_char,
    authors_array: *const *const c_char,
) {
    // Convert the C strings to Rust strings
    let command_name_opt = if command_name.is_null() {
        None
    } else {
        CStr::from_ptr(command_name).to_str().ok()
    };

    let package_str = if package.is_null() {
        ""
    } else {
        CStr::from_ptr(package).to_str().unwrap_or("")
    };

    let version_str = if version.is_null() {
        ""
    } else {
        CStr::from_ptr(version).to_str().unwrap_or("")
    };

    // Collect authors from the NULL-terminated array
    let mut authors = Vec::new();

    if !authors_array.is_null() {
        let mut i = 0;
        loop {
            let author = *authors_array.add(i);
            if author.is_null() {
                break;
            }

            if let Ok(author_str) = CStr::from_ptr(author).to_str() {
                authors.push(author_str);
            }

            i += 1;
        }
    }

    // Create a wrapper around the FILE pointer
    struct FileWriterLocal<'a>(&'a mut libc::FILE);

    impl<'a> Write for FileWriterLocal<'a> {
        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
            let written =
                unsafe { libc::fwrite(buf.as_ptr() as *const c_void, 1, buf.len(), self.0) };
            Ok(written)
        }

        fn flush(&mut self) -> io::Result<()> {
            let result = unsafe { libc::fflush(self.0) };
            if result == 0 {
                Ok(())
            } else {
                Err(io::Error::last_os_error())
            }
        }
    }

    // Create a writer that wraps the FILE pointer
    let writer = FileWriterLocal(unsafe { &mut *stream });

    // Call the Rust implementation
    let _ = version_etc_rust(writer, command_name_opt, package_str, version_str, &authors);
}

pub struct SuffixLengthWrapper {
    val: usize,
}

impl SuffixLengthWrapper {
    pub fn new() -> Self {
        // Initialize with the current value of the global variable
        let current_value = unsafe { suffix_length as usize };
        Self { val: current_value }
    }

    pub fn get(&self) -> usize {
        // Read from the global variable
        unsafe { suffix_length as usize }
    }

    pub fn set(&mut self, val: usize) {
        // Update the struct field
        self.val = val;
        // Update the global variable
        unsafe {
            suffix_length = val as idx_t;
        }
    }
}

pub struct SuffixAlphabetWrapper {
    val: String,
}

// Using a thread-safe wrapper for our string
static SUFFIX_ALPHABET_STORAGE: Mutex<Option<CString>> = Mutex::new(None);

impl SuffixAlphabetWrapper {
    pub fn new() -> Self {
        // Read the current value of the global variable
        let val = unsafe {
            if suffix_alphabet.is_null() {
                String::new()
            } else {
                CStr::from_ptr(suffix_alphabet)
                    .to_string_lossy()
                    .into_owned()
            }
        };

        Self { val }
    }

    pub fn get(&self) -> String {
        // Read directly from the global variable for consistency
        unsafe {
            if suffix_alphabet.is_null() {
                String::new()
            } else {
                CStr::from_ptr(suffix_alphabet)
                    .to_string_lossy()
                    .into_owned()
            }
        }
    }

    pub fn set(&mut self, val: String) {
        // Update the struct field
        self.val = val.clone();

        // Convert to C string and update the global variable
        let c_string = CString::new(val).unwrap_or_default();

        // Update our storage and the global variable
        let mut storage = SUFFIX_ALPHABET_STORAGE.lock().unwrap();

        // Update the global variable safely
        unsafe {
            suffix_alphabet = c_string.as_ptr();
        }

        // Store the CString in our mutex to keep it alive
        *storage = Some(c_string);
    }
}

pub struct SuffixAutoWrapper {
    val: bool,
}

impl SuffixAutoWrapper {
    pub fn new() -> Self {
        // Initialize the global variable if needed
        static INIT: Once = Once::new();
        static mut ATOMIC_SUFFIX_AUTO: Option<AtomicBool> = None;

        INIT.call_once(|| unsafe {
            ATOMIC_SUFFIX_AUTO = Some(AtomicBool::new(suffix_auto));
        });

        let current_value = unsafe { ATOMIC_SUFFIX_AUTO.as_ref().unwrap().load(Ordering::SeqCst) };

        Self { val: current_value }
    }

    pub fn get(&self) -> bool {
        static INIT: Once = Once::new();
        static mut ATOMIC_SUFFIX_AUTO: Option<AtomicBool> = None;

        INIT.call_once(|| unsafe {
            ATOMIC_SUFFIX_AUTO = Some(AtomicBool::new(suffix_auto));
        });

        unsafe { ATOMIC_SUFFIX_AUTO.as_ref().unwrap().load(Ordering::SeqCst) }
    }

    pub fn set(&mut self, val: bool) {
        static INIT: Once = Once::new();
        static mut ATOMIC_SUFFIX_AUTO: Option<AtomicBool> = None;

        INIT.call_once(|| unsafe {
            ATOMIC_SUFFIX_AUTO = Some(AtomicBool::new(suffix_auto));
        });

        self.val = val;

        unsafe {
            ATOMIC_SUFFIX_AUTO
                .as_ref()
                .unwrap()
                .store(val, Ordering::SeqCst);
            suffix_auto = val;
        }
    }
}

pub struct NumericSuffixStartWrapper {
    val: Option<String>,
}

impl NumericSuffixStartWrapper {
    pub fn new() -> Self {
        let val = Self::read_global();
        Self { val }
    }

    pub fn get(&self) -> Option<String> {
        // Read directly from the global to ensure we have the latest value
        Self::read_global()
    }

    pub fn set(&mut self, val: Option<String>) {
        self.val = val.clone();

        // Update the global variable
        unsafe {
            if let Some(s) = &val {
                // Convert String to CString and leak it to get a static pointer
                let c_string = CString::new(s.as_str()).unwrap();
                let ptr = c_string.into_raw();
                numeric_suffix_start = ptr as *const c_char;
            } else {
                numeric_suffix_start = ptr::null();
            }
        }
    }

    // Helper method to read from the global variable
    fn read_global() -> Option<String> {
        unsafe {
            if numeric_suffix_start.is_null() {
                None
            } else {
                // Convert the C string to a Rust String
                let c_str = CStr::from_ptr(numeric_suffix_start);
                match c_str.to_str() {
                    Ok(s) => Some(s.to_string()),
                    Err(_) => None, // Handle invalid UTF-8
                }
            }
        }
    }
}

#[derive(Clone, Copy, PartialEq, Eq)]
enum Split_type_rust {
    Type_undef,
    Type_bytes,
    Type_byteslines,
    Type_lines,
    Type_digits,
    Type_chunk_bytes,
    Type_chunk_lines,
    Type_rr,
}

/// Sets the suffix length based on the number of units and split type.
fn set_suffix_length_rust(
    n_units: i64,
    split_type: Split_type_rust,
    suffix_length_wrapper: &mut SuffixLengthWrapper,
    suffix_alphabet_wrapper: &SuffixAlphabetWrapper,
    suffix_auto_wrapper: &mut SuffixAutoWrapper,
    numeric_suffix_start_wrapper: &NumericSuffixStartWrapper,
) {
    let mut suffix_length_needed = 0;

    // The suffix auto length feature is incompatible with
    // a user specified start value as the generated suffixes
    // are not all consecutive.
    if numeric_suffix_start_wrapper.get().is_some() {
        suffix_auto_wrapper.set(false);
    }

    // Auto-calculate the suffix length if the number of files is given.
    if matches!(
        split_type,
        Split_type_rust::Type_chunk_bytes
            | Split_type_rust::Type_chunk_lines
            | Split_type_rust::Type_rr
    ) {
        let mut n_units_end = n_units - 1;

        if let Some(numeric_start) = &numeric_suffix_start_wrapper.get() {
            // Parse the numeric suffix start value
            match numeric_start.parse::<i64>() {
                Ok(n_start) if n_start < n_units => {
                    // Restrict auto adjustment to avoid arbitrary suffix size increments
                    // that would break sort order for files from multiple split runs
                    n_units_end = n_units_end.saturating_add(n_start);
                }
                _ => {}
            }
        }

        let alphabet_len = suffix_alphabet_wrapper.get().len() as i64;

        // Calculate required suffix length
        loop {
            suffix_length_needed += 1;
            n_units_end /= alphabet_len;
            if n_units_end == 0 {
                break;
            }
        }

        suffix_auto_wrapper.set(false);
    }

    // Check if suffix length was set by user
    if suffix_length_wrapper.get() > 0 {
        if suffix_length_wrapper.get() < suffix_length_needed as usize {
            // Create a C-compatible error message
            let error_msg = format!(
                "the suffix length needs to be at least {}",
                suffix_length_needed
            );
            let c_error_msg = CString::new(error_msg).unwrap();

            unsafe {
                // Call error function with failing exit status (1)
                error(1, 0, gettext(c_error_msg.as_ptr()));
            }
            // The C code would exit here, but we'll just return
            return;
        }

        suffix_auto_wrapper.set(false);
    } else {
        // Set suffix length to max of 2 or the needed length
        suffix_length_wrapper.set(max(2, suffix_length_needed as usize));
    }
}
#[no_mangle]
pub unsafe extern "C" fn set_suffix_length(n_units: i64, split_type: c_int) {
    // Create wrappers for global variables
    let mut suffix_length_wrapper = SuffixLengthWrapper::new();
    let suffix_alphabet_wrapper = SuffixAlphabetWrapper::new();
    let mut suffix_auto_wrapper = SuffixAutoWrapper::new();
    let numeric_suffix_start_wrapper = NumericSuffixStartWrapper::new();

    // Convert C enum to Rust enum
    let split_type_rust = match split_type {
        0 => Split_type_rust::Type_undef,
        1 => Split_type_rust::Type_bytes,
        2 => Split_type_rust::Type_byteslines,
        3 => Split_type_rust::Type_lines,
        4 => Split_type_rust::Type_digits,
        5 => Split_type_rust::Type_chunk_bytes,
        6 => Split_type_rust::Type_chunk_lines,
        7 => Split_type_rust::Type_rr,
        _ => Split_type_rust::Type_undef, // Default case
    };

    // Call the Rust implementation
    set_suffix_length_rust(
        n_units,
        split_type_rust,
        &mut suffix_length_wrapper,
        &suffix_alphabet_wrapper,
        &mut suffix_auto_wrapper,
        &numeric_suffix_start_wrapper,
    );
}

/// Opens a file and ensures it has the desired file descriptor number.
///
/// If the file is successfully opened but gets a different file descriptor,
/// this function will duplicate it to the desired descriptor and close the original.
///
/// # Arguments
///
/// * `desired_fd` - The file descriptor number that should be used
/// * `file` - Path to the file to open
/// * `flags` - Open flags (O_RDONLY, O_WRONLY, etc.)
/// * `mode` - File mode to use when creating files
///
/// # Returns
///
/// * The file descriptor on success, or a negative value on error
fn fd_reopen_rust(desired_fd: RawFd, file: &str, flags: i32, mode: u32) -> RawFd {
    // Create OpenOptions from the flags and mode
    let mut options = OpenOptions::new();

    // Set basic access mode
    if flags & libc::O_RDWR != 0 {
        options.read(true).write(true);
    } else if flags & libc::O_WRONLY != 0 {
        options.write(true);
    } else {
        options.read(true);
    }

    // Set other flags
    if flags & libc::O_APPEND != 0 {
        options.append(true);
    }
    if flags & libc::O_CREAT != 0 {
        options.create(true);
    }
    if flags & libc::O_TRUNC != 0 {
        options.truncate(true);
    }
    if flags & libc::O_EXCL != 0 {
        options.create_new(true);
    }

    // Set the mode (permissions)
    options.mode(mode);

    // Try to open the file
    let file_result = options.open(file);

    match file_result {
        Ok(file) => {
            let fd = file.as_raw_fd();

            // If we got the desired fd or an error, return it
            if fd == desired_fd {
                // Prevent the file from being closed when it goes out of scope
                std::mem::forget(file);
                return fd;
            }

            // We need to duplicate the fd to the desired one
            let raw_fd = file.into_raw_fd();

            // Use dup2 to duplicate to the desired fd
            let result = unsafe { libc::dup2(raw_fd, desired_fd) };

            // Get the current errno
            let errno = io::Error::last_os_error();

            // Close the original fd
            unsafe { libc::close(raw_fd) };

            // If dup2 failed, propagate the error
            if result < 0 {
                // Set the errno back to what it was after dup2
                set_errno(errno);
                return result;
            }

            result
        }
        Err(e) => {
            // Convert the error to a negative fd
            set_errno(e);
            -1
        }
    }
}

// Helper function to set errno from an io::Error
fn set_errno(error: io::Error) {
    unsafe {
        *libc::__errno_location() = error.raw_os_error().unwrap_or(libc::EINVAL);
    }
}
#[no_mangle]
pub unsafe extern "C" fn fd_reopen(
    desired_fd: libc::c_int,
    file: *const libc::c_char,
    flags: libc::c_int,
    mode: libc::mode_t,
) -> libc::c_int {
    // Convert C string to Rust string
    let file_str = match CStr::from_ptr(file).to_str() {
        Ok(s) => s,
        Err(_) => {
            *libc::__errno_location() = libc::EINVAL;
            return -1;
        }
    };

    // Call the Rust implementation
    fd_reopen_rust(desired_fd, file_str, flags, mode as u32)
}

pub struct quoting_options_rust {
    /// Basic quoting style.
    pub style: Quoting_style_rust,

    /// Additional flags. Bitwise combination of enum quoting_flags.
    pub flags: i32,

    /// Quote the characters indicated by this bit vector even if the
    /// quoting style would not normally require them to be quoted.
    pub quote_these_too: Vec<u32>,

    /// The left quote for custom_quoting_style.
    pub left_quote: Option<String>,

    /// The right quote for custom_quoting_style.
    pub right_quote: Option<String>,
}

/// Quotes a string according to the specified quoting style.
///
/// This is a safe Rust implementation that wraps the unsafe FFI call.
fn quotearg_style_rust(style: ::std::os::raw::c_uint, arg: &str) -> String {
    // Convert Rust string to C string
    let c_arg = CString::new(arg).expect("String contains null byte");

    unsafe {
        // Call the FFI function
        let result = quotearg_n_style_mem(0, style, c_arg.as_ptr(), arg.len());

        // Convert the result back to a Rust string
        if result.is_null() {
            String::new()
        } else {
            CStr::from_ptr(result).to_string_lossy().into_owned()
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn quotearg_style(
    s: ::std::os::raw::c_uint,
    arg: *const c_char,
) -> *mut c_char {
    // Safety check for null pointer
    if arg.is_null() {
        return ptr::null_mut();
    }

    // Convert C string to Rust string
    let arg_str = match CStr::from_ptr(arg).to_str() {
        Ok(s) => s,
        Err(_) => return ptr::null_mut(),
    };

    // Call the Rust implementation
    let result = quotearg_style_rust(s, arg_str);

    // Convert the result back to a C string
    // Note: This creates a memory leak as we're not freeing this memory
    // The original C code likely has a memory management strategy for this
    let c_result = CString::new(result).expect("String contains null byte");
    c_result.into_raw()
}

/// Advises the kernel about access patterns for a file.
///
/// # Arguments
///
/// * `fd` - A file descriptor
/// * `offset` - The offset within the file
/// * `len` - The length of the region to advise on
/// * `advice` - The advice to give to the kernel
fn fdadvise_rust(fd: c_int, offset: libc::off_t, len: libc::off_t, advice: c_int) {
    // We need to use unsafe to call the C function
    unsafe {
        // Ignore the return value as the original C code does
        let _ = libc::posix_fadvise(fd, offset, len, advice);
    }
}
#[no_mangle]
pub unsafe extern "C" fn fdadvise(fd: c_int, offset: libc::off_t, len: libc::off_t, advice: c_int) {
    fdadvise_rust(fd, offset, len, advice);
}

/// Calculate an appropriate block size for I/O operations
///
/// This function determines an optimal block size for I/O operations by examining
/// the file's reported block size and applying various heuristics to improve performance.
fn io_blksize_rust(st_blksize: i64, st_mode: u32) -> i64 {
    const IO_BUFSIZE: i64 = 8192; // Assuming this is the value from the C code

    // Get the block size, with fallback to 512 if invalid
    let blocksize = if 0 < st_blksize && st_blksize <= (isize::MAX as i64 / 8 + 1) {
        st_blksize
    } else {
        512
    };

    // Use a blocksize of at least IO_BUFSIZE bytes
    let mut blocksize = if blocksize <= 0 {
        IO_BUFSIZE
    } else {
        blocksize
    };

    // Round up to a multiple of IO_BUFSIZE
    blocksize += (IO_BUFSIZE - 1) - (IO_BUFSIZE - 1) % blocksize;

    // For regular files, if blocksize is not a power of two, use the next power of two
    let is_regular_file = (st_mode & 0o170000) == 0o100000;
    if is_regular_file && (blocksize & (blocksize - 1)) != 0 {
        // Use Rust's built-in leading_zeros instead of the C function
        let leading_zeros = (blocksize as u64).leading_zeros();
        let power = 1u64 << (64 - leading_zeros);

        if power <= i64::MAX as u64 {
            blocksize = power as i64;
        }
    }

    // Don't exceed the maximum safe blocksize
    let max_safe_blocksize = std::cmp::min(i64::MAX, usize::MAX as i64) / 2 + 1;

    std::cmp::min(max_safe_blocksize, blocksize)
}
#[no_mangle]
pub unsafe extern "C" fn io_blksize(st: *const libc::stat) -> libc::c_long {
    if st.is_null() {
        return 8192; // Return IO_BUFSIZE if null pointer
    }

    let st_blksize = (*st).st_blksize as i64;
    let st_mode = (*st).st_mode as u32;

    io_blksize_rust(st_blksize, st_mode) as libc::c_long
}

/// Allocates memory with the specified alignment and size.
///
/// Returns a pointer to the allocated memory, or None if allocation fails.
fn alignalloc_rust(alignment: usize, size: usize) -> Option<NonNull<u8>> {
    // Create a layout with the specified alignment and size
    match Layout::from_size_align(size, alignment) {
        Ok(layout) => {
            // Allocate memory using the layout
            let ptr = unsafe { alloc::alloc(layout) };

            // Check if allocation succeeded
            if ptr.is_null() {
                None
            } else {
                // Convert the pointer to NonNull<u8>
                NonNull::new(ptr)
            }
        }
        Err(_) => None,
    }
}
#[no_mangle]

/// Allocates memory with the specified alignment and size.
/// Terminates the program if allocation fails.
///
/// # Arguments
///
/// * `alignment` - The alignment requirement for the allocation
/// * `size` - The size of the allocation in bytes
///
/// # Returns
///
/// A non-null pointer to the allocated memory
fn xalignalloc_rust(alignment: usize, size: usize) -> NonNull<u8> {
    match alignalloc_rust(alignment, size) {
        Some(ptr) => ptr,
        None => {
            // Since we can't safely replace xalloc_die with a Rust equivalent,
            // we need to call the C function
            unsafe { xalloc_die() };
            // This point is never reached as xalloc_die doesn't return
            unreachable!();
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn xalignalloc(alignment: libc::size_t, size: libc::size_t) -> *mut c_void {
    let result = xalignalloc_rust(alignment as usize, size as usize);
    result.as_ptr() as *mut c_void
}

/// Determines if the st_size field of a file's metadata is usable.
///
/// This function checks if the file is a regular file or a symbolic link.
fn usable_st_size_rust(metadata: &std::fs::Metadata) -> bool {
    // In Rust, we can use the file_type() method to check the file type
    let file_type = metadata.file_type();

    // Check if it's a regular file or a symbolic link
    file_type.is_file() || file_type.is_symlink()
}
#[no_mangle]
pub unsafe extern "C" fn usable_st_size(sb: *const libc::stat) -> bool {
    if sb.is_null() {
        return false;
    }

    // Check if it's a regular file (S_IFREG) or a symbolic link (S_IFLNK)
    let mode = (*sb).st_mode;
    let is_regular_file = (mode & libc::S_IFMT) == libc::S_IFREG;
    let is_symlink = (mode & libc::S_IFMT) == libc::S_IFLNK;

    is_regular_file || is_symlink
}

/// Represents a time value with seconds and nanoseconds components
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct timespec_rust {
    /// Seconds
    pub tv_sec: i64,
    /// Nanoseconds
    pub tv_nsec: i64,
}

pub struct stat_rust {
    /// Device
    pub st_dev: u64,

    /// File serial number
    pub st_ino: u64,

    /// Link count
    pub st_nlink: u64,

    /// File mode
    pub st_mode: u32,

    /// User ID of the file's owner
    pub st_uid: u32,

    /// Group ID of the file's group
    pub st_gid: u32,

    /// Padding
    pub __pad0: i32,

    /// Device number, if device
    pub st_rdev: u64,

    /// Size of file, in bytes
    pub st_size: i64,

    /// Optimal block size for I/O
    pub st_blksize: i64,

    /// Number 512-byte blocks allocated
    pub st_blocks: i64,

    /// Time of last access
    pub st_atim: timespec_rust,

    /// Time of last modification
    pub st_mtim: timespec_rust,

    /// Time of last status change
    pub st_ctim: timespec_rust,

    /// Reserved
    pub __glibc_reserved: [i64; 3],
}

/// Creates a safer file descriptor by duplicating standard streams (0, 1, 2)
/// and closing the original.
///
/// This function ensures that the returned file descriptor is not one of the standard
/// streams (stdin, stdout, stderr).
fn fd_safer_rust(fd: RawFd) -> RawFd {
    // Check if fd is one of the standard streams (0, 1, 2)
    if (0..=2).contains(&fd) {
        // Duplicate the file descriptor
        match dup_safer_rust(fd) {
            Ok(new_fd) => {
                // Store the current errno
                let original_error = Error::last_os_error();

                // Close the original fd
                let _ = unsafe { File::from_raw_fd(fd) };
                // The File's Drop implementation will close the fd

                // Restore the original error state
                // (In Rust, we don't need to explicitly set errno)

                // Return the new fd
                new_fd
            }
            Err(_) => fd, // If duplication fails, return the original fd
        }
    } else {
        // If not a standard stream, return as is
        fd
    }
}

/// A Rust implementation of dup_safer
fn dup_safer_rust(fd: RawFd) -> Result<RawFd, Error> {
    // Use the nix crate's safe wrapper around dup, or implement directly
    let file = unsafe { File::from_raw_fd(fd) };
    let new_fd = file.try_clone()?.into_raw_fd();
    // Forget the original file to avoid closing the fd
    std::mem::forget(file);
    Ok(new_fd)
}
#[no_mangle]
pub unsafe extern "C" fn fd_safer(fd: c_int) -> c_int {
    // Convert C int to Rust RawFd, call the Rust implementation, and convert back
    fd_safer_rust(fd) as c_int
}

pub struct _IO_FILE_rust {
    pub flags: i32, // High-order word is _IO_MAGIC; rest is flags.

    // The following pointers correspond to the C++ streambuf protocol.
    pub read_ptr: Option<NonNull<u8>>,   // Current read pointer
    pub read_end: Option<NonNull<u8>>,   // End of get area.
    pub read_base: Option<NonNull<u8>>,  // Start of putback+get area.
    pub write_base: Option<NonNull<u8>>, // Start of put area.
    pub write_ptr: Option<NonNull<u8>>,  // Current put pointer.
    pub write_end: Option<NonNull<u8>>,  // End of put area.
    pub buf_base: Option<NonNull<u8>>,   // Start of reserve area.
    pub buf_end: Option<NonNull<u8>>,    // End of reserve area.

    // The following fields are used to support backing up and undo.
    pub save_base: Option<NonNull<u8>>, // Pointer to start of non-current get area.
    pub backup_base: Option<NonNull<u8>>, // Pointer to first valid character of backup area
    pub save_end: Option<NonNull<u8>>,  // Pointer to end of non-current get area.

    pub markers: Option<NonNull<_IO_marker>>,

    pub chain: Option<NonNull<_IO_FILE>>,

    pub fileno: i32,
    pub flags2: i32,
    pub old_offset: i64, // Assuming __off_t is 64-bit

    // 1+column number of pbase(); 0 is unknown.
    pub cur_column: u16,
    pub vtable_offset: i8,
    pub shortbuf: [u8; 1],

    pub lock: Option<NonNull<c_void>>, // Using c_void for _IO_lock_t

    pub offset: i64, // Assuming __off64_t is 64-bit
    // Wide character stream stuff.
    pub codecvt: Option<NonNull<_IO_codecvt>>,
    pub wide_data: Option<NonNull<_IO_wide_data>>,
    pub freeres_list: Option<NonNull<_IO_FILE>>,
    pub freeres_buf: Option<NonNull<c_void>>,
    pub pad5: usize,
    pub mode: i32,
    // Make sure we don't get into trouble again.
    pub unused2: [u8; 15 * 4 - 4 * 8 - 8], // 15 * sizeof(int) - 4 * sizeof(void*) - sizeof(size_t)
}

/// Flushes a file stream in a way that preserves the file position for input streams.
///
/// This is a Rust implementation of rpl_fflush that avoids the issues with
/// flushing input streams on certain platforms like mingw.
fn rpl_fflush_rust(stream: Option<&mut File>) -> io::Result<()> {
    // If stream is None or it's not a reading stream, we can safely flush it
    match stream {
        None => {
            // Flush all open output streams
            // In Rust, we don't have a direct equivalent to flushing all streams
            // So we just return Ok for this case
            Ok(())
        }
        Some(file) => {
            // In the original C code, we'd check if the stream is in reading mode
            // In Rust, we don't have direct access to this information
            // Instead, we'll just flush the stream which is safe in Rust
            // as it won't discard the read buffer or change the file position
            file.flush()
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn rpl_fflush(stream: *mut libc::FILE) -> libc::c_int {
    // Convert the C FILE pointer to a Rust File if possible
    let result = if stream.is_null() {
        // Handle NULL stream case - in Rust we'd pass None
        rpl_fflush_rust(None)
    } else {
        // For non-null streams, we need to use the C fflush function
        // since we can't safely convert a libc::FILE to a Rust File

        // Check if this is a reading stream (equivalent to __freading check)
        // Since we don't have access to __freading, we'll just call fflush directly

        // In the original C code:
        // 1. We'd check if it's a reading stream
        // 2. If reading, we'd clear the ungetc buffer and then flush
        // 3. If not reading, we'd just flush

        // Since we can't properly implement this in safe Rust without the
        // internal functions, we'll just call the C fflush function
        if libc::fflush(stream) == 0 {
            Ok(())
        } else {
            Err(io::Error::last_os_error())
        }
    };

    match result {
        Ok(_) => 0,
        Err(_) => -1,
    }
}

/// Closes a file stream with additional error handling.
///
/// This is a Rust reimplementation of the C `rpl_fclose` function.
fn rpl_fclose_rust(file: &mut File) -> io::Result<()> {
    let fd = file.as_raw_fd();

    // Check if the file is seekable (equivalent to lseek check in C)
    let is_seekable = {
        let seek_result = file.seek(io::SeekFrom::Current(0));
        seek_result.is_ok()
    };

    // We're missing __freading, so we'll assume all files need flushing
    // This is safer than potentially skipping a needed flush
    let mut saved_error = None;

    // Only flush if the file is seekable
    if is_seekable {
        if let Err(e) = rpl_fflush_rust(Some(file)) {
            saved_error = Some(e);
        }
    }

    // We need to clone the file descriptor since we can't move out of a reference
    let raw_fd = file.as_raw_fd();

    // Close the file using the standard library
    // Note: This doesn't actually close the file since we're just using as_raw_fd
    // The actual closing will be done by the C fclose function in the wrapper
    let result = unsafe {
        match libc::dup(raw_fd) {
            -1 => Err(io::Error::last_os_error()),
            duplicated_fd => match libc::close(duplicated_fd) {
                0 => Ok(()),
                _ => Err(io::Error::last_os_error()),
            },
        }
    };

    // If we had an error during flush, return that error
    if let Some(e) = saved_error {
        return Err(e);
    }

    // Return the result of the close operation
    result
}
#[no_mangle]
pub unsafe extern "C" fn rpl_fclose(fp: *mut libc::FILE) -> c_int {
    let mut saved_errno = 0;
    let mut result = 0;

    // Don't change behavior on memstreams
    let fd = unsafe { fileno(fp as *mut _) };
    if fd < 0 {
        return unsafe { fclose(fp as *mut _) };
    }

    // We only need to flush the file if it is not reading or if it is seekable
    let is_reading = false; // We can't access __freading, assume false for safety
    let is_seekable = unsafe { lseek(fd, 0, SEEK_CUR) != -1 };

    if (!is_reading || is_seekable) && unsafe { rpl_fflush(fp as *mut _) } != 0 {
        saved_errno = unsafe { *__errno_location() };
    }

    // Call fclose and invoke all hooks of the overridden close
    result = unsafe { fclose(fp as *mut _) };

    if saved_errno != 0 {
        unsafe { *__errno_location() = saved_errno };
        result = -1;
    }

    result
}

pub struct FilterCommandWrapper {
    val: Option<String>,
}

impl FilterCommandWrapper {
    pub fn new() -> Self {
        let current_value = unsafe {
            if filter_command.is_null() {
                None
            } else {
                // Convert C string to Rust String
                Some(
                    CStr::from_ptr(filter_command)
                        .to_string_lossy()
                        .into_owned(),
                )
            }
        };

        Self { val: current_value }
    }

    pub fn get(&self) -> Option<String> {
        unsafe {
            if filter_command.is_null() {
                None
            } else {
                // Convert C string to Rust String
                Some(
                    CStr::from_ptr(filter_command)
                        .to_string_lossy()
                        .into_owned(),
                )
            }
        }
    }

    pub fn set(&mut self, val: Option<String>) {
        self.val = val.clone();

        unsafe {
            // Free the old value if it exists
            if !filter_command.is_null() {
                // We don't know how the original string was allocated,
                // so we can't safely free it here. In a real implementation,
                // you would need to know the allocation strategy.
                // This is a limitation of converting from static mut.
            }

            // Set the new value
            match &val {
                Some(s) => {
                    let c_string = CString::new(s.as_str()).unwrap();
                    // This leaks memory, but it's necessary since we're
                    // setting a static variable that needs to outlive this function
                    let ptr = c_string.into_raw();
                    filter_command = ptr as *const c_char;
                }
                None => {
                    filter_command = ptr::null();
                }
            }
        }
    }
}

/// Determines if an error is ignorable based on the filter command state.
///
/// Returns true if filter_command is set and the error is a broken pipe (32).
fn ignorable_rust(filter_command_wrapper: &FilterCommandWrapper, err: i32) -> bool {
    filter_command_wrapper.get().is_some() && err == 32 // Broken pipe
}
#[no_mangle]
pub unsafe extern "C" fn ignorable(err: libc::c_int) -> bool {
    let filter_command_wrapper = FilterCommandWrapper::new();
    ignorable_rust(&filter_command_wrapper, err as i32)
}

pub struct OpenPipesWrapper {
    val: Vec<i32>,
}

impl OpenPipesWrapper {
    pub fn new() -> Self {
        let mut wrapper = OpenPipesWrapper { val: Vec::new() };

        unsafe {
            if !open_pipes.is_null() {
                // Assuming open_pipes points to an array of integers terminated by -1 or similar
                // This is a common pattern for pipe arrays in C
                let mut index = 0;
                loop {
                    let fd = *open_pipes.add(index);
                    if fd < 0 {
                        // Assuming -1 or negative value as terminator
                        break;
                    }
                    wrapper.val.push(fd);
                    index += 1;
                }
            }
        }

        wrapper
    }

    
    pub fn set(&mut self, val: Vec<i32>) {
        self.val = val.clone();

        unsafe {
            // Free the old array if it exists
            if !open_pipes.is_null() {
                libc::free(open_pipes as *mut libc::c_void);
            }

            // Allocate new memory for the array (+1 for terminator)
            let size = (val.len() + 1) * std::mem::size_of::<c_int>();
            open_pipes = libc::malloc(size) as *mut c_int;

            // Copy the values
            for (i, &fd) in val.iter().enumerate() {
                *open_pipes.add(i) = fd;
            }

            // Add terminator
            *open_pipes.add(val.len()) = -1;
        }
    }
}

pub struct NOpenPipesWrapper {
    val: i32,
}

impl NOpenPipesWrapper {
    pub fn new() -> Self {
        // Read the current value of the global variable
        let current_value = unsafe { n_open_pipes };

        // Convert to idiomatic Rust type (i32)
        Self { val: current_value }
    }

    pub fn get(&self) -> i32 {
        // Read the current value from the global variable
        unsafe { n_open_pipes }
    }

    pub fn set(&mut self, val: i32) {
        // Update the struct field
        self.val = val;

        // Update the global variable
        unsafe {
            n_open_pipes = val;
        }
    }
}

/// Reallocates memory with size checking.
///
/// This function is a safer Rust implementation of the C `irealloc` function.
/// It handles memory reallocation with proper size checking.
///
/// # Arguments
///
/// * `ptr` - Optional pointer to previously allocated memory
/// * `size` - Requested size in bytes
///
/// # Returns
///
/// A pointer to the reallocated memory, or None if allocation failed
fn irealloc_rust(ptr: Option<NonNull<u8>>, size: usize) -> Option<NonNull<u8>> {
    // Check if size is within allowed range
    if size <= usize::MAX {
        // Work around realloc behavior by treating zero size as 1
        let adjusted_size = size | (!size as usize & 1);

        match ptr {
            Some(p) => {
                // We need to know the layout of the original allocation
                // Since we don't have this information, we'll use a conservative approach
                let min_align = std::mem::align_of::<usize>();
                let layout = Layout::from_size_align(adjusted_size, min_align).ok()?;

                // Safety: We're reallocating memory that was previously allocated
                // and we're ensuring the size is valid
                let new_ptr = unsafe {
                    let raw_ptr = p.as_ptr();
                    rust_realloc(raw_ptr, layout, adjusted_size)
                };

                NonNull::new(new_ptr)
            }
            None => {
                // If ptr is null, allocate new memory
                let layout =
                    Layout::from_size_align(adjusted_size, std::mem::align_of::<usize>()).ok()?;
                let new_ptr = unsafe { alloc::alloc(layout) };
                NonNull::new(new_ptr)
            }
        }
    } else {
        // Size is too large, return None to indicate allocation failure
        None
    }
}
#[no_mangle]

fn xirealloc_rust(p: Option<NonNull<u8>>, s: usize) -> NonNull<u8> {
    check_nonnull_rust(irealloc_rust(p, s))
}
#[no_mangle]
pub unsafe extern "C" fn xirealloc(p: *mut c_void, s: usize) -> *mut c_void {
    let ptr = if p.is_null() {
        None
    } else {
        NonNull::new(p as *mut u8)
    };

    let result = xirealloc_rust(ptr, s);

    result.as_ptr() as *mut c_void
}

/// Allocates zeroed memory for an array of `n` elements of `s` bytes each.
///
/// Returns a pointer to the allocated memory, or `None` if the allocation fails.
fn icalloc_rust(n: usize, s: usize) -> Option<*mut u8> {
    const MAX_SIZE: usize = usize::MAX;

    // Check for overflow in n
    if MAX_SIZE < n {
        if s != 0 {
            // Would overflow, return None to indicate allocation failure
            return None;
        }
        // If s is 0, we can safely set n to 0
        return Some(ptr::null_mut());
    }

    // Check for overflow in s
    if MAX_SIZE < s {
        if n != 0 {
            // Would overflow, return None to indicate allocation failure
            return None;
        }
        // If n is 0, we can safely set s to 0
        return Some(ptr::null_mut());
    }

    // Check for multiplication overflow
    let size = match n.checked_mul(s) {
        Some(size) if size > 0 => size,
        Some(_) => return Some(ptr::null_mut()), // Zero-sized allocation
        None => return None,                     // Multiplication overflow
    };

    // Create a layout for the allocation
    let layout = match alloc::Layout::from_size_align(size, std::mem::align_of::<u8>()) {
        Ok(layout) => layout,
        Err(_) => return None,
    };

    // Perform the allocation
    unsafe {
        let ptr = alloc::alloc_zeroed(layout);
        if ptr.is_null() {
            None
        } else {
            Some(ptr)
        }
    }
}
#[no_mangle]

fn xicalloc_rust(n: usize, s: usize) -> *mut u8 {
    check_nonnull_rust(icalloc_rust(n, s))
}
#[no_mangle]
pub unsafe extern "C" fn xicalloc(n: libc::size_t, s: libc::size_t) -> *mut c_void {
    xicalloc_rust(n as usize, s as usize) as *mut c_void
}

pub struct OutfileMidWrapper {
    val: Option<String>,
}

impl OutfileMidWrapper {
    pub fn new() -> Self {
        // Read the current value of the global variable
        let val = unsafe {
            if outfile_mid.is_null() {
                None
            } else {
                // Convert C string to Rust String
                Some(CStr::from_ptr(outfile_mid).to_string_lossy().into_owned())
            }
        };

        OutfileMidWrapper { val }
    }

    pub fn get(&self) -> Option<String> {
        // Read directly from the global variable
        unsafe {
            if outfile_mid.is_null() {
                None
            } else {
                // Convert C string to Rust String
                Some(CStr::from_ptr(outfile_mid).to_string_lossy().into_owned())
            }
        }
    }

    }

pub struct AdditionalSuffixWrapper {
    val: Option<String>,
}

impl AdditionalSuffixWrapper {
    pub fn new() -> Self {
        Self {
            val: Self::get_global(),
        }
    }

    pub fn get(&self) -> Option<String> {
        Self::get_global()
    }

    
    // Helper method to read from the global variable
    fn get_global() -> Option<String> {
        unsafe {
            if additional_suffix.is_null() {
                None
            } else {
                // Convert C string to Rust String
                CStr::from_ptr(additional_suffix)
                    .to_string_lossy()
                    .into_owned()
                    .into()
            }
        }
    }
}

pub struct OutbaseWrapper {
    val: Option<String>,
}

impl OutbaseWrapper {
    pub fn new() -> Self {
        let current_value = unsafe {
            if outbase.is_null() {
                None
            } else {
                // Convert C string to Rust String
                Some(CStr::from_ptr(outbase).to_string_lossy().into_owned())
            }
        };

        Self { val: current_value }
    }

    pub fn get(&self) -> Option<String> {
        unsafe {
            if outbase.is_null() {
                None
            } else {
                // Convert C string to Rust String
                Some(CStr::from_ptr(outbase).to_string_lossy().into_owned())
            }
        }
    }

    pub fn set(&mut self, val: Option<String>) {
        self.val = val.clone();

        unsafe {
            // Update the global variable
            match &val {
                Some(s) => {
                    // Convert Rust String to C string and leak it
                    // (we're assuming the global variable's lifetime is managed elsewhere)
                    let c_string = CString::new(s.as_str()).unwrap();
                    outbase = c_string.as_ptr();
                    // Intentionally leak the CString to keep the pointer valid
                    std::mem::forget(c_string);
                }
                None => {
                    outbase = std::ptr::null();
                }
            }
        }
    }
}

pub struct OutfileWrapper {
    val: String,
}

impl OutfileWrapper {
    pub fn new() -> Self {
        // Initialize with the current value of the global variable
        let current_value = unsafe {
            if outfile.is_null() {
                String::new()
            } else {
                CStr::from_ptr(outfile).to_string_lossy().into_owned()
            }
        };

        OutfileWrapper { val: current_value }
    }

    pub fn get(&self) -> String {
        // Read the current value from the global variable
        unsafe {
            if outfile.is_null() {
                String::new()
            } else {
                CStr::from_ptr(outfile).to_string_lossy().into_owned()
            }
        }
    }

    pub fn set(&mut self, val: String) {
        // Update the struct field
        self.val = val.clone();

        // Update the global variable
        unsafe {
            // Free the old value if it exists
            if !outfile.is_null() {
                // Convert the raw pointer to a CString to properly free it
                let _ = CString::from_raw(outfile);
            }

            // Allocate and set the new value
            if val.is_empty() {
                outfile = ptr::null_mut();
            } else {
                // Create a new CString and forget its management
                let c_string = CString::new(val).unwrap_or_default();
                outfile = c_string.into_raw();
            }
        }
    }
}

/// Opens a file safely, ensuring the returned file descriptor is safe.
///
/// This is a Rust reimplementation of the C `open_safer` function.
fn open_safer_rust(file: &OsStr, flags: libc::c_int, mode: libc::mode_t) -> RawFd {
    // Open the file with the appropriate mode
    let file_result = OpenOptions::new()
        .read((flags & libc::O_RDONLY) != 0 || (flags & libc::O_RDWR) != 0)
        .write((flags & libc::O_WRONLY) != 0 || (flags & libc::O_RDWR) != 0)
        .append((flags & libc::O_APPEND) != 0)
        .truncate((flags & libc::O_TRUNC) != 0)
        .create((flags & libc::O_CREAT) != 0)
        .create_new((flags & libc::O_EXCL != 0) && (flags & libc::O_CREAT) != 0)
        .mode(mode as u32)
        .custom_flags(
            flags
                & !(libc::O_RDONLY
                    | libc::O_WRONLY
                    | libc::O_RDWR
                    | libc::O_APPEND
                    | libc::O_TRUNC
                    | libc::O_CREAT
                    | libc::O_EXCL),
        )
        .open(file);

    match file_result {
        Ok(file) => {
            // Get the raw file descriptor and make it safer
            let fd = file.into_raw_fd();
            fd_safer_rust(fd)
        }
        Err(_) => -1, // Return -1 on error, similar to the C open function
    }
}
#[no_mangle]
pub unsafe extern "C" fn open_safer(
    file: *const c_char,
    flags: libc::c_int,
    mode: libc::mode_t,
) -> libc::c_int {
    // Check if file pointer is valid
    if file.is_null() {
        return -1;
    }

    // Convert C string to Rust OsStr
    let file_cstr = CStr::from_ptr(file);
    let file_osstr = OsStr::from_bytes(file_cstr.to_bytes());

    // Determine if we should use the mode parameter
    let actual_mode = if (flags & 0o100) != 0 { mode } else { 0 };

    // Call the Rust implementation
    open_safer_rust(file_osstr, flags, actual_mode) as libc::c_int
}

/// Checks if two files have the same inode.
///
/// This function compares the device ID and inode number of two files
/// to determine if they refer to the same file.
fn psame_inode_rust(a: &std::fs::Metadata, b: &std::fs::Metadata) -> bool {
    a.dev() == b.dev() && a.ino() == b.ino()
}
#[no_mangle]
pub unsafe extern "C" fn psame_inode(a: *const libc::stat, b: *const libc::stat) -> bool {
    if a.is_null() || b.is_null() {
        return false;
    }

    // The original C function uses a bitwise operation to check equality
    // !((a->st_dev ^ b->st_dev) | (a->st_ino ^ b->st_ino))
    !(((*a).st_dev ^ (*b).st_dev != 0) || ((*a).st_ino ^ (*b).st_ino != 0))
}

pub struct OpenPipesAllocWrapper {
    val: usize,
}

impl OpenPipesAllocWrapper {
    pub fn new() -> Self {
        // Initialize with the current value of the global variable
        let current_value = unsafe { open_pipes_alloc };
        Self {
            val: current_value as usize,
        }
    }

    pub fn get(&self) -> usize {
        // Read the global variable directly
        unsafe { open_pipes_alloc as usize }
    }

    pub fn set(&mut self, val: usize) {
        // Update both the struct field and the global variable
        self.val = val;
        unsafe {
            open_pipes_alloc = val as idx_t;
        }
    }
}

pub struct InStatBufWrapper {
    val: Metadata,
}

impl InStatBufWrapper {
    pub fn new() -> Self {
        // Read the current value from the global variable
        let metadata = unsafe {
            // In a real implementation, you would convert the libc::stat to Metadata
            // This is a simplified example that creates a placeholder Metadata
            let file = File::open("/dev/null").unwrap();
            file.metadata().unwrap()
        };

        InStatBufWrapper { val: metadata }
    }

    
    pub fn set(&mut self, val: Metadata) {
        // Update our local value
        self.val = val.clone();

        // Update the global variable
        unsafe {
            // In a real implementation, you would convert Metadata to libc::stat
            // and update the global variable
            // Example: in_stat_buf = convert_metadata_to_stat(val);
        }
    }
}

pub struct FilterPidWrapper {
    val: i32,
}

impl FilterPidWrapper {
    pub fn new() -> Self {
        // Read the current value of the global variable
        let current_val = unsafe { filter_pid };

        // Convert to idiomatic type and create a new instance
        FilterPidWrapper {
            val: current_val as i32,
        }
    }

    pub fn get(&self) -> i32 {
        // Read from the global variable
        let current_val = unsafe { filter_pid };
        current_val as i32
    }

    pub fn set(&mut self, val: i32) {
        // Update the struct field
        self.val = val;

        // Update the global variable
        unsafe {
            filter_pid = val as libc::pid_t;
        }
    }
}

pub struct VerboseWrapper {
    val: bool,
}

impl VerboseWrapper {
    pub fn new() -> Self {
        // Use a static AtomicBool to safely access the global
        static VERBOSE_ATOMIC: AtomicBool = AtomicBool::new(false);
        static INIT: Once = Once::new();

        // On first call, initialize from the global variable
        INIT.call_once(|| unsafe {
            VERBOSE_ATOMIC.store(verbose, Ordering::SeqCst);
        });

        Self {
            val: VERBOSE_ATOMIC.load(Ordering::SeqCst),
        }
    }

    pub fn get(&self) -> bool {
        // Read from the atomic global
        static VERBOSE_ATOMIC: AtomicBool = AtomicBool::new(false);
        VERBOSE_ATOMIC.load(Ordering::SeqCst)
    }

    pub fn set(&mut self, val: bool) {
        // Update both the struct field and the global atomic
        self.val = val;

        static VERBOSE_ATOMIC: AtomicBool = AtomicBool::new(false);
        VERBOSE_ATOMIC.store(val, Ordering::SeqCst);

        // Also update the original global for compatibility
        unsafe {
            verbose = val;
        }
    }
}

pub struct DefaultSigpipeWrapper {
    val: bool,
}

impl DefaultSigpipeWrapper {
    pub fn new() -> Self {
        // Initialize the wrapper with the current value of the global variable
        let current_value = unsafe { default_SIGPIPE };
        Self { val: current_value }
    }

    pub fn get(&self) -> bool {
        // Read the global variable directly
        unsafe { default_SIGPIPE }
    }

    pub fn set(&mut self, val: bool) {
        // Update both the struct field and the global variable
        self.val = val;
        unsafe {
            default_SIGPIPE = val;
        }
    }
}

fn safe_write_rust(fd: i32, buf: &[u8], mut count: usize) -> Result<usize, i32> {
    // Define SYS_BUFSIZE_MAX if it's not already defined
    const SYS_BUFSIZE_MAX: usize = 0x7ffff000; // This is a common value, adjust if needed

    loop {
        // Create a file from the raw file descriptor, but don't close it when dropped
        let file = unsafe { File::from_raw_fd(fd) };
        let result = file.as_raw_fd(); // Get the fd back to prevent closing on drop
        let mut file_ref = &file;

        // Only use the smaller of count or buf.len()
        let actual_count = count.min(buf.len());

        match file_ref.write(&buf[..actual_count]) {
            Ok(written) => {
                // Prevent the file from being closed when dropped
                let _ = file.into_raw_fd();
                return Ok(written);
            }
            Err(e) => {
                // Prevent the file from being closed when dropped
                let _ = file.into_raw_fd();

                match e.raw_os_error() {
                    Some(EINTR) => continue, // Interrupted system call, retry
                    Some(EINVAL) if count > SYS_BUFSIZE_MAX => {
                        // Invalid argument and count is too large
                        count = SYS_BUFSIZE_MAX;
                        continue;
                    }
                    Some(errno) => return Err(errno),
                    None => return Err(-1), // Unknown error
                }
            }
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn safe_write(
    fd: libc::c_int,
    buf: *const libc::c_void,
    count: libc::size_t,
) -> libc::size_t {
    if buf.is_null() {
        return 0;
    }

    let buffer = std::slice::from_raw_parts(buf as *const u8, count);

    match safe_write_rust(fd, buffer, count) {
        Ok(result) => result,
        Err(errno) => {
            // Set errno
            *libc::__errno_location() = errno;
            // Return -1 as error indicator
            usize::MAX // This is -1 when interpreted as a signed value
        }
    }
}

fn full_write_rust(fd: i32, buf: &[u8], count: usize) -> usize {
    let mut total = 0;
    let mut remaining_buf = &buf[..count.min(buf.len())];
    let mut remaining_count = count.min(buf.len());

    while remaining_count > 0 {
        match safe_write_rust(fd, remaining_buf, remaining_count) {
            Ok(0) => {
                // In Rust, we'd typically use proper error handling instead of setting errno
                // But to match the C behavior, we'll set errno to ENOSPC (28)
                unsafe {
                    *__errno_location() = 28; // ENOSPC - No space left on device
                }
                break;
            }
            Ok(n) => {
                total += n;
                remaining_buf = &remaining_buf[n..];
                remaining_count -= n;
            }
            Err(_) => break,
        }
    }

    total
}
#[no_mangle]
pub unsafe extern "C" fn full_write(
    fd: libc::c_int,
    buf: *const libc::c_void,
    count: libc::size_t,
) -> libc::size_t {
    if buf.is_null() {
        return 0;
    }

    let buffer = std::slice::from_raw_parts(buf as *const u8, count);
    full_write_rust(fd, buffer, count)
}

pub struct OutputDescWrapper {
    val: i32,
}

impl OutputDescWrapper {
    pub fn new() -> Self {
        // Read the current value of the global variable
        let current_value = unsafe { output_desc };
        Self { val: current_value }
    }

    pub fn get(&self) -> i32 {
        // Read the current value of the global variable
        unsafe { output_desc }
    }

    }

pub struct ElideEmptyFilesWrapper {
    val: bool,
}

impl ElideEmptyFilesWrapper {
    pub fn new() -> Self {
        // Initialize with the current value of the global variable
        let current_value = unsafe { elide_empty_files };
        Self { val: current_value }
    }

    pub fn get(&self) -> bool {
        // Read the global variable directly
        unsafe { elide_empty_files }
    }

    pub fn set(&mut self, val: bool) {
        // Update the struct field
        self.val = val;

        // Update the global variable
        unsafe {
            elide_empty_files = val;
        }
    }
}

pub struct EolcharWrapper {
    val: i32,
}

impl EolcharWrapper {
    /// Creates a new wrapper by reading the current value of the global variable
    pub fn new() -> Self {
        let current_value = unsafe { eolchar };
        Self { val: current_value }
    }

    /// Gets the current value of the global variable
    pub fn get(&self) -> i32 {
        unsafe { eolchar }
    }

    /// Sets a new value to both the struct field and the global variable
    pub fn set(&mut self, val: i32) {
        self.val = val;
        unsafe {
            eolchar = val;
        }
    }
}

pub struct InfileWrapper {
    val: Option<PathBuf>,
}

impl InfileWrapper {
    pub fn new() -> Self {
        // Initialize with the current value of the global variable
        let current_val = Self::read_global();
        Self { val: current_val }
    }

    pub fn get(&self) -> Option<PathBuf> {
        // Return a clone of the current value
        self.val.clone()
    }

    pub fn set(&mut self, val: Option<PathBuf>) {
        // Update the struct field
        self.val = val.clone();

        // Update the global variable
        unsafe {
            if let Some(path) = &val {
                // Convert PathBuf to CString
                if let Ok(c_string) = CString::new(path.to_string_lossy().as_bytes()) {
                    // Store the pointer in the global variable
                    // We need to leak the memory to ensure it lives long enough
                    let ptr = c_string.into_raw();
                    crate::infile = ptr as *const c_char;
                } else {
                    // If conversion fails, set to null
                    crate::infile = ptr::null();
                }
            } else {
                // If None, set to null
                crate::infile = ptr::null();
            }
        }
    }

    // Helper method to read from the global variable
    fn read_global() -> Option<PathBuf> {
        unsafe {
            if !crate::infile.is_null() {
                // Convert the C string to a Rust string
                let c_str = CStr::from_ptr(crate::infile);
                if let Ok(str_slice) = c_str.to_str() {
                    return Some(PathBuf::from(str_slice));
                }
            }
            None
        }
    }
}

/// Reallocates memory for an array of elements.
///
/// This function attempts to reallocate memory for an array of `n` elements,
/// each of size `s`. If either `n` or `s` is 0, it treats them as 1 to ensure
/// consistent behavior.
///
/// # Returns
/// - `Some(ptr)` - A pointer to the reallocated memory
/// - `None` - If the reallocation failed or if the size would exceed usize::MAX
fn ireallocarray_rust(p: Option<NonNull<u8>>, n: usize, s: usize) -> Option<NonNull<u8>> {
    // Check if the multiplication would overflow
    if let Some(total_size) = n.checked_mul(s) {
        // Handle zero sizes by treating them as 1
        let nx = if n == 0 { 1 } else { n };
        let sx = if s == 0 { 1 } else { s };

        // Calculate the new size
        let new_size = nx.saturating_mul(sx);

        // Perform the reallocation
        match p {
            Some(ptr) => {
                // We need to know the old layout to reallocate
                // Since we don't have this information, we'll use a new allocation and copy
                let new_ptr = unsafe {
                    let new_ptr = alloc::alloc(Layout::from_size_align_unchecked(new_size, 1));
                    if !new_ptr.is_null() {
                        // Copy the old data (we don't know how much to copy, so we use new_size)
                        // This is not ideal but matches the C behavior
                        ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr, new_size);
                        // Free the old allocation
                        alloc::dealloc(ptr.as_ptr(), Layout::from_size_align_unchecked(1, 1));
                    }
                    new_ptr
                };

                NonNull::new(new_ptr)
            }
            None => {
                // Just allocate new memory
                let new_ptr =
                    unsafe { alloc::alloc(Layout::from_size_align_unchecked(new_size, 1)) };
                NonNull::new(new_ptr)
            }
        }
    } else {
        // Multiplication would overflow, return None
        None
    }
}
#[no_mangle]
pub unsafe extern "C" fn ireallocarray(
    p: *mut c_void,
    n: libc::size_t,
    s: libc::size_t,
) -> *mut c_void {
    // Convert C pointer to Rust Option<NonNull<u8>>
    let rust_ptr = if p.is_null() {
        None
    } else {
        NonNull::new(p as *mut u8)
    };

    // Call the Rust implementation
    match ireallocarray_rust(rust_ptr, n, s) {
        Some(ptr) => ptr.as_ptr() as *mut c_void,
        None => {
            // Equivalent to _gl_alloc_nomem()
            // Since we can't call the original function, we'll just return null
            // which indicates allocation failure
            ptr::null_mut()
        }
    }
}

/// Allocates memory for an array of `n` elements of `s` bytes each.
///
/// # Arguments
///
/// * `n` - Number of elements
/// * `s` - Size of each element in bytes
///
/// # Returns
///
/// A pointer to the allocated memory, or null pointer if allocation fails.
fn xinmalloc_rust(n: usize, s: usize) -> *mut c_void {
    // Call the existing xireallocarray function with null pointer
    // to allocate new memory
    unsafe {
        let null_ptr: *mut c_void = ptr::null_mut();

        // Convert usize to isize, handling potential conversion errors
        let n_isize = match isize::try_from(n) {
            Ok(val) => val,
            Err(_) => return ptr::null_mut(), // Return null on overflow
        };

        let s_isize = match isize::try_from(s) {
            Ok(val) => val,
            Err(_) => return ptr::null_mut(), // Return null on overflow
        };

        crate::xireallocarray(null_ptr, n_isize, s_isize)
    }
}
#[no_mangle]
pub unsafe extern "C" fn xinmalloc(n: usize, s: usize) -> *mut c_void {
    xinmalloc_rust(n, s)
}

/// Allocates a new buffer and copies the contents of the source buffer into it.
///
/// # Arguments
///
/// * `p` - A slice of bytes to duplicate
///
/// # Returns
///
/// A `NonNull<u8>` pointer to the newly allocated memory containing a copy of the input data
fn xmemdup_rust(p: &[u8]) -> NonNull<u8> {
    // Allocate memory using xmalloc_rust
    let ptr = xmalloc_rust(p.len());

    // Create a mutable slice from the allocated memory
    let dest_slice = unsafe { slice::from_raw_parts_mut(ptr.as_ptr(), p.len()) };

    // Copy the data
    dest_slice.copy_from_slice(p);

    // Return the pointer
    ptr
}
#[no_mangle]
pub unsafe extern "C" fn xmemdup(p: *const c_void, s: libc::size_t) -> *mut c_void {
    // Safety: We trust that the pointer is valid for the given size
    let src_slice = slice::from_raw_parts(p as *const u8, s);

    // Call the Rust implementation
    let result = xmemdup_rust(src_slice);

    // Convert back to *mut c_void for C compatibility
    result.as_ptr() as *mut c_void
}

/// Creates a duplicate of a string in newly allocated memory.
///
/// This is a Rust reimplementation of the C `xstrdup` function.
fn xstrdup_rust(string: *const c_char) -> *mut c_char {
    if string.is_null() {
        return ptr::null_mut();
    }

    unsafe {
        // Get the length of the string (including the null terminator)
        let len = libc::strlen(string) + 1;

        // Create a slice from the C string
        let slice = std::slice::from_raw_parts(string as *const u8, len as usize);

        // Use xmemdup_rust to allocate and copy the bytes
        let result = xmemdup_rust(slice);

        // Return as *mut c_char
        result.as_ptr() as *mut c_char
    }
}
/// Creates a duplicate of a string in newly allocated memory.
///
/// # Safety
///
/// The caller must ensure that `string` is a valid, null-terminated C string.
/// The returned pointer must be freed with the appropriate deallocation function.
#[no_mangle]
pub unsafe extern "C" fn xstrdup(string: *const c_char) -> *mut c_char {
    xstrdup_rust(string)
}

pub struct UnbufferedWrapper {
    val: bool,
}

impl UnbufferedWrapper {
    pub fn new() -> Self {
        // Initialize with the current value of the global variable
        let current_value = unsafe { unbuffered };
        Self { val: current_value }
    }

    pub fn get(&self) -> bool {
        // Read the global variable directly
        unsafe { unbuffered }
    }

    pub fn set(&mut self, val: bool) {
        // Update our local value
        self.val = val;

        // Update the global variable
        unsafe {
            unbuffered = val;
        }
    }
}

pub struct of_info_rust {
    pub of_name: String,
    pub ofd: i32,
    pub ofile: Option<File>,
    pub opid: u32,
}

pub struct LongoptsWrapper {
    val: Vec<GetoptOption>,
}

// Idiomatic Rust equivalent of the C `option` struct
#[derive(Debug, Clone, Default)]
pub struct GetoptOption {
    pub name: Option<String>,
    pub has_arg: bool,
    pub flag: Option<i32>,
    pub val: char,
}

impl LongoptsWrapper {
    pub fn new() -> Self {
        // Read the current value of the global variable
        let options = unsafe { Self::get_global() };
        LongoptsWrapper { val: options }
    }

    pub fn get(&self) -> Vec<GetoptOption> {
        // Read directly from the global variable
        unsafe { Self::get_global() }
    }

    pub fn set(&mut self, val: Vec<GetoptOption>) {
        self.val = val.clone();

        // Update the global variable
        unsafe {
            Self::set_global(&self.val);
        }
    }

    // Helper function to read from the global variable
    unsafe fn get_global() -> Vec<GetoptOption> {
        // Since the original is a zero-sized array, we return an empty Vec
        Vec::new()
    }

    // Helper function to write to the global variable
    unsafe fn set_global(_val: &Vec<GetoptOption>) {
        // Since the original is a zero-sized array, there's nothing to write
        // In a real implementation with a non-zero-sized array, this would update the global variable
    }
}

pub struct VersionWrapper {
    val: String,
}

impl VersionWrapper {
    pub fn new() -> Self {
        let version_str = unsafe {
            if Version.is_null() {
                String::new()
            } else {
                CStr::from_ptr(Version).to_string_lossy().into_owned()
            }
        };

        Self { val: version_str }
    }

    pub fn get(&self) -> String {
        unsafe {
            if Version.is_null() {
                String::new()
            } else {
                CStr::from_ptr(Version).to_string_lossy().into_owned()
            }
        }
    }

    pub fn set(&mut self, val: String) {
        // Update the struct field
        self.val = val;

        // Convert to C string and update the global variable
        let c_string = CString::new(self.val.clone()).unwrap_or_default();
        unsafe {
            // Store the pointer to the global variable
            // Note: This creates a memory leak if called multiple times
            // as we're not freeing the previous value
            Version = c_string.into_raw() as *const c_char;
        }
    }
}
